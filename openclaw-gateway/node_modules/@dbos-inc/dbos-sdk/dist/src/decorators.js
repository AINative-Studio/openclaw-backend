"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DBOSDeploy = exports.DBOSInitializer = exports.OrmEntities = exports.Step = exports.StoredProcedure = exports.Transaction = exports.Workflow = exports.RequiredRole = exports.configureInstance = exports.DefaultArgOptional = exports.DefaultArgRequired = exports.DefaultRequiredRole = exports.ArgVarchar = exports.ArgDate = exports.ArgName = exports.LogMask = exports.SkipLogging = exports.ArgOptional = exports.ArgRequired = exports.associateMethodWithEventReceiver = exports.associateClassWithEventReceiver = exports.getOrCreateClassRegistration = exports.getAllRegisteredClasses = exports.registerAndWrapContextFreeFunction = exports.registerAndWrapFunction = exports.getOrCreateMethodArgsRegistration = exports.getConfiguredInstance = exports.getRegisteredOperations = exports.registerFunctionWrapper = exports.getRegisteredMethodName = exports.getRegisteredMethodClassName = exports.ClassRegistration = exports.ConfiguredInstance = exports.MethodRegistration = exports.MethodParameter = exports.ArgRequiredOptions = exports.LogMasks = exports.DBOSDataType = void 0;
require("reflect-metadata");
const crypto = __importStar(require("crypto"));
const context_1 = require("./context");
const error_1 = require("./error");
const data_validation_1 = require("./data_validation");
class DBOSDataType {
    dataType = "text";
    length = -1;
    precision = -1;
    scale = -1;
    /** Varchar has length */
    static varchar(length) {
        const dt = new DBOSDataType();
        dt.dataType = "varchar";
        dt.length = length;
        return dt;
    }
    /** Some decimal has precision / scale (as opposed to floating point decimal) */
    static decimal(precision, scale) {
        const dt = new DBOSDataType();
        dt.dataType = "decimal";
        dt.precision = precision;
        dt.scale = scale;
        return dt;
    }
    /** Take type from reflect metadata */
    // eslint-disable-next-line @typescript-eslint/ban-types
    static fromArg(arg) {
        const dt = new DBOSDataType();
        if (arg === String) {
            dt.dataType = "text";
        }
        else if (arg === Date) {
            dt.dataType = "timestamp";
        }
        else if (arg === Number) {
            dt.dataType = "double";
        }
        else if (arg === Boolean) {
            dt.dataType = "boolean";
        }
        else {
            dt.dataType = "json";
        }
        return dt;
    }
    formatAsString() {
        let rv = this.dataType;
        if (this.dataType === "varchar" && this.length > 0) {
            rv += `(${this.length})`;
        }
        if (this.dataType === "decimal" && this.precision > 0) {
            if (this.scale > 0) {
                rv += `(${this.precision},${this.scale})`;
            }
            else {
                rv += `(${this.precision})`;
            }
        }
        return rv;
    }
}
exports.DBOSDataType = DBOSDataType;
const paramMetadataKey = Symbol.for("dbos:parameter");
/* Arguments parsing heuristic:
 * - Convert the function to a string
 * - Minify the function
 * - Remove everything before the first open parenthesis and after the first closed parenthesis
 * This will obviously not work on code that has been obfuscated or optimized as the names get
 *   changed to be really small and useless.
 **/
// eslint-disable-next-line @typescript-eslint/ban-types
function getArgNames(func) {
    let fn = func.toString();
    fn = fn.replace(/\s/g, "");
    fn = fn.substring(fn.indexOf("(") + 1, fn.indexOf(")"));
    return fn.split(",");
}
var LogMasks;
(function (LogMasks) {
    LogMasks["NONE"] = "NONE";
    LogMasks["HASH"] = "HASH";
    LogMasks["SKIP"] = "SKIP";
})(LogMasks || (exports.LogMasks = LogMasks = {}));
var ArgRequiredOptions;
(function (ArgRequiredOptions) {
    ArgRequiredOptions["REQUIRED"] = "REQUIRED";
    ArgRequiredOptions["OPTIONAL"] = "OPTIONAL";
    ArgRequiredOptions["DEFAULT"] = "DEFAULT";
})(ArgRequiredOptions || (exports.ArgRequiredOptions = ArgRequiredOptions = {}));
class MethodParameter {
    name = "";
    required = ArgRequiredOptions.DEFAULT;
    validate = true;
    logMask = LogMasks.NONE;
    // eslint-disable-next-line @typescript-eslint/ban-types
    argType = String;
    dataType;
    index = -1;
    // eslint-disable-next-line @typescript-eslint/ban-types
    constructor(idx, at) {
        this.index = idx;
        this.argType = at;
        this.dataType = DBOSDataType.fromArg(at);
    }
}
exports.MethodParameter = MethodParameter;
class MethodRegistration {
    passContext;
    defaults;
    name = "";
    className = "";
    requiredRole = undefined;
    args = [];
    constructor(origFunc, isInstance, passContext) {
        this.passContext = passContext;
        this.origFunction = origFunc;
        this.isInstance = isInstance;
    }
    needInitialized = true;
    isInstance;
    origFunction;
    registeredFunction;
    wrappedFunction = undefined;
    workflowConfig;
    txnConfig;
    commConfig;
    procConfig;
    eventReceiverInfo = new Map();
    init = false;
    invoke(pthis, args) {
        return this.registeredFunction.call(pthis, ...args);
    }
    getRequiredRoles() {
        if (this.requiredRole) {
            return this.requiredRole;
        }
        return this.defaults?.requiredRole || [];
    }
}
exports.MethodRegistration = MethodRegistration;
class ConfiguredInstance {
    name;
    constructor(name) {
        this.name = name;
    }
}
exports.ConfiguredInstance = ConfiguredInstance;
class ClassRegistration {
    name = "";
    requiredRole;
    defaultArgRequired = ArgRequiredOptions.REQUIRED;
    needsInitialized = true;
    // eslint-disable-next-line @typescript-eslint/ban-types
    ormEntities = [];
    registeredOperations = new Map();
    configuredInstances = new Map();
    eventReceiverInfo = new Map();
    ctor;
    constructor(ctor) {
        this.ctor = ctor;
    }
}
exports.ClassRegistration = ClassRegistration;
// This is a bit ugly, if we got the class / instance it would help avoid this auxiliary structure
const methodToRegistration = new Map();
function getRegisteredMethodClassName(func) {
    let rv = "";
    if (methodToRegistration.has(func)) {
        rv = methodToRegistration.get(func).className;
    }
    return rv;
}
exports.getRegisteredMethodClassName = getRegisteredMethodClassName;
function getRegisteredMethodName(func) {
    let rv = "";
    if (methodToRegistration.has(func)) {
        rv = methodToRegistration.get(func).name;
    }
    return rv;
}
exports.getRegisteredMethodName = getRegisteredMethodName;
function registerFunctionWrapper(func, reg) {
    methodToRegistration.set(func, reg);
}
exports.registerFunctionWrapper = registerFunctionWrapper;
function getRegisteredOperations(target) {
    const registeredOperations = [];
    if (typeof target === 'function') { // Constructor case
        const classReg = classesByName.get(target.name);
        classReg?.registeredOperations?.forEach((m) => registeredOperations.push(m));
    }
    else {
        let current = target;
        while (current) {
            const cname = current.constructor.name;
            if (classesByName.has(cname)) {
                registeredOperations.push(...getRegisteredOperations(current.constructor));
            }
            current = Object.getPrototypeOf(current);
        }
    }
    return registeredOperations;
}
exports.getRegisteredOperations = getRegisteredOperations;
function getConfiguredInstance(clsname, cfgname) {
    const classReg = classesByName.get(clsname);
    if (!classReg)
        return null;
    return classReg.configuredInstances.get(cfgname) ?? null;
}
exports.getConfiguredInstance = getConfiguredInstance;
////////////////////////////////////////////////////////////////////////////////
// DECORATOR REGISTRATION
// These manage registration objects, creating them at decorator evaluation time
// and making wrapped methods available for function registration at runtime
// initialization time.
////////////////////////////////////////////////////////////////////////////////
function getOrCreateMethodArgsRegistration(target, propertyKey) {
    let regtarget = target;
    if (typeof regtarget !== 'function') {
        regtarget = regtarget.constructor;
    }
    let mParameters = Reflect.getOwnMetadata(paramMetadataKey, regtarget, propertyKey) || [];
    if (!mParameters.length) {
        // eslint-disable-next-line @typescript-eslint/ban-types
        const designParamTypes = Reflect.getMetadata("design:paramtypes", target, propertyKey);
        mParameters = designParamTypes.map((value, index) => new MethodParameter(index, value));
        Reflect.defineMetadata(paramMetadataKey, mParameters, regtarget, propertyKey);
    }
    return mParameters;
}
exports.getOrCreateMethodArgsRegistration = getOrCreateMethodArgsRegistration;
function generateSaltedHash(data, salt) {
    const hash = crypto.createHash("sha256"); // You can use other algorithms like 'md5', 'sha512', etc.
    hash.update(data + salt);
    return hash.digest("hex");
}
function getOrCreateMethodRegistration(target, propertyKey, descriptor, passContext) {
    let regtarget;
    let isInstance = false;
    if (typeof target === 'function') {
        // Static method case
        regtarget = target;
    }
    else {
        // Instance method case
        regtarget = target.constructor;
        isInstance = true;
    }
    const classReg = getOrCreateClassRegistration(regtarget);
    const fname = propertyKey.toString();
    if (!classReg.registeredOperations.has(fname)) {
        classReg.registeredOperations.set(fname, new MethodRegistration(descriptor.value, isInstance, passContext));
    }
    const methReg = classReg.registeredOperations.get(fname);
    if (methReg.needInitialized) {
        methReg.needInitialized = false;
        methReg.name = fname;
        methReg.className = classReg.name;
        methReg.defaults = classReg;
        methReg.args = getOrCreateMethodArgsRegistration(target, propertyKey);
        const argNames = getArgNames(descriptor.value);
        methReg.args.forEach((e) => {
            if (!e.name) {
                if (e.index < argNames.length) {
                    e.name = argNames[e.index];
                }
                if (e.index === 0 && passContext) { // The first argument is always the context.
                    e.logMask = LogMasks.SKIP;
                }
                // TODO else warn/log something
            }
        });
        const wrappedMethod = async function (...rawArgs) {
            let opCtx = undefined;
            if (passContext) {
                opCtx = rawArgs[0];
            }
            else {
                opCtx = (0, context_1.getCurrentDBOSContext)();
            }
            // Validate the user authentication and populate the role field
            const requiredRoles = methReg.getRequiredRoles();
            if (requiredRoles.length > 0) {
                opCtx.span.setAttribute("requiredRoles", requiredRoles);
                const curRoles = opCtx.authenticatedRoles;
                let authorized = false;
                const set = new Set(curRoles);
                for (const role of requiredRoles) {
                    if (set.has(role)) {
                        authorized = true;
                        opCtx.assumedRole = role;
                        break;
                    }
                }
                if (!authorized) {
                    const err = new error_1.DBOSNotAuthorizedError(`User does not have a role with permission to call ${methReg.name}`, 403);
                    opCtx.span.addEvent("DBOSNotAuthorizedError", { message: err.message });
                    throw err;
                }
            }
            const validatedArgs = (0, data_validation_1.validateMethodArgs)(methReg, rawArgs);
            // Argument logging
            validatedArgs.forEach((argValue, idx) => {
                let isCtx = false;
                // TODO: we assume the first argument is always a context, need a more robust way to test it.
                if (idx === 0 && passContext) {
                    // Context -- I suppose we could just instanceof
                    opCtx = validatedArgs[0];
                    isCtx = true;
                }
                let loggedArgValue = argValue;
                if (isCtx || methReg.args[idx].logMask === LogMasks.SKIP) {
                    return;
                }
                else {
                    if (methReg.args[idx].logMask !== LogMasks.NONE) {
                        // For now this means hash
                        if (methReg.args[idx].dataType.dataType === "json") {
                            loggedArgValue = generateSaltedHash(JSON.stringify(argValue), "JSONSALT");
                        }
                        else {
                            // Yes, we are doing the same as above for now.
                            // It can be better if we have verified the type of the data
                            loggedArgValue = generateSaltedHash(JSON.stringify(argValue), "DBOSSALT");
                        }
                    }
                    opCtx?.span.setAttribute(methReg.args[idx].name, loggedArgValue);
                }
            });
            return methReg.origFunction.call(this, ...validatedArgs);
        };
        Object.defineProperty(wrappedMethod, "name", {
            value: methReg.name,
        });
        descriptor.value = wrappedMethod;
        methReg.registeredFunction = wrappedMethod;
        methodToRegistration.set(methReg.registeredFunction, methReg);
        methodToRegistration.set(methReg.origFunction, methReg);
    }
    return methReg;
}
function registerAndWrapFunction(target, propertyKey, descriptor) {
    if (!descriptor.value) {
        throw Error("Use of decorator when original method is undefined");
    }
    const registration = getOrCreateMethodRegistration(target, propertyKey, descriptor, true);
    return { descriptor, registration };
}
exports.registerAndWrapFunction = registerAndWrapFunction;
function registerAndWrapContextFreeFunction(target, propertyKey, descriptor) {
    if (!descriptor.value) {
        throw Error("Use of decorator when original method is undefined");
    }
    const registration = getOrCreateMethodRegistration(target, propertyKey, descriptor, false);
    return { descriptor, registration };
}
exports.registerAndWrapContextFreeFunction = registerAndWrapContextFreeFunction;
const classesByName = new Map();
function getAllRegisteredClasses() {
    const ctors = [];
    for (const [_cn, creg] of classesByName) {
        ctors.push(creg.ctor);
    }
    return ctors;
}
exports.getAllRegisteredClasses = getAllRegisteredClasses;
function getOrCreateClassRegistration(ctor) {
    const name = ctor.name;
    if (!classesByName.has(name)) {
        classesByName.set(name, new ClassRegistration(ctor));
    }
    const clsReg = classesByName.get(name);
    if (clsReg.needsInitialized) {
        clsReg.name = name;
        clsReg.needsInitialized = false;
    }
    return clsReg;
}
exports.getOrCreateClassRegistration = getOrCreateClassRegistration;
function associateClassWithEventReceiver(rcvr, ctor) {
    const clsReg = getOrCreateClassRegistration(ctor);
    if (!clsReg.eventReceiverInfo.has(rcvr)) {
        clsReg.eventReceiverInfo.set(rcvr, {});
    }
    return clsReg.eventReceiverInfo.get(rcvr);
}
exports.associateClassWithEventReceiver = associateClassWithEventReceiver;
function associateMethodWithEventReceiver(rcvr, target, propertyKey, inDescriptor) {
    const { descriptor, registration } = registerAndWrapFunction(target, propertyKey, inDescriptor);
    if (!registration.eventReceiverInfo.has(rcvr)) {
        registration.eventReceiverInfo.set(rcvr, {});
    }
    return { descriptor, registration, receiverInfo: registration.eventReceiverInfo.get(rcvr) };
}
exports.associateMethodWithEventReceiver = associateMethodWithEventReceiver;
//////////////////////////
/* PARAMETER DECORATORS */
//////////////////////////
function ArgRequired(target, propertyKey, parameterIndex) {
    const existingParameters = getOrCreateMethodArgsRegistration(target, propertyKey);
    const curParam = existingParameters[parameterIndex];
    curParam.required = ArgRequiredOptions.REQUIRED;
}
exports.ArgRequired = ArgRequired;
function ArgOptional(target, propertyKey, parameterIndex) {
    const existingParameters = getOrCreateMethodArgsRegistration(target, propertyKey);
    const curParam = existingParameters[parameterIndex];
    curParam.required = ArgRequiredOptions.OPTIONAL;
}
exports.ArgOptional = ArgOptional;
function SkipLogging(target, propertyKey, parameterIndex) {
    const existingParameters = getOrCreateMethodArgsRegistration(target, propertyKey);
    const curParam = existingParameters[parameterIndex];
    curParam.logMask = LogMasks.SKIP;
}
exports.SkipLogging = SkipLogging;
function LogMask(mask) {
    return function (target, propertyKey, parameterIndex) {
        const existingParameters = getOrCreateMethodArgsRegistration(target, propertyKey);
        const curParam = existingParameters[parameterIndex];
        curParam.logMask = mask;
    };
}
exports.LogMask = LogMask;
function ArgName(name) {
    return function (target, propertyKey, parameterIndex) {
        const existingParameters = getOrCreateMethodArgsRegistration(target, propertyKey);
        const curParam = existingParameters[parameterIndex];
        curParam.name = name;
    };
}
exports.ArgName = ArgName;
function ArgDate() {
    return function (target, propertyKey, parameterIndex) {
        const existingParameters = getOrCreateMethodArgsRegistration(target, propertyKey);
        const curParam = existingParameters[parameterIndex];
        curParam.dataType.dataType = 'timestamp';
    };
}
exports.ArgDate = ArgDate;
function ArgVarchar(length) {
    return function (target, propertyKey, parameterIndex) {
        const existingParameters = getOrCreateMethodArgsRegistration(target, propertyKey);
        const curParam = existingParameters[parameterIndex];
        curParam.dataType = DBOSDataType.varchar(length);
    };
}
exports.ArgVarchar = ArgVarchar;
///////////////////////
/* CLASS DECORATORS */
///////////////////////
function DefaultRequiredRole(anyOf) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function clsdec(ctor) {
        const clsreg = getOrCreateClassRegistration(ctor);
        clsreg.requiredRole = anyOf;
    }
    return clsdec;
}
exports.DefaultRequiredRole = DefaultRequiredRole;
function DefaultArgRequired(ctor) {
    const clsreg = getOrCreateClassRegistration(ctor);
    clsreg.defaultArgRequired = ArgRequiredOptions.REQUIRED;
}
exports.DefaultArgRequired = DefaultArgRequired;
function DefaultArgOptional(ctor) {
    const clsreg = getOrCreateClassRegistration(ctor);
    clsreg.defaultArgRequired = ArgRequiredOptions.OPTIONAL;
}
exports.DefaultArgOptional = DefaultArgOptional;
function configureInstance(cls, name, ...args) {
    const inst = new cls(name, ...args);
    const creg = getOrCreateClassRegistration(cls);
    if (creg.configuredInstances.has(name)) {
        throw new error_1.DBOSError(`Registration: Class ${cls.name} configuration ${name} is not unique`);
    }
    creg.configuredInstances.set(name, inst);
    return inst;
}
exports.configureInstance = configureInstance;
///////////////////////
/* METHOD DECORATORS */
///////////////////////
function RequiredRole(anyOf) {
    function apidec(target, propertyKey, inDescriptor) {
        const { descriptor, registration } = registerAndWrapFunction(target, propertyKey, inDescriptor);
        registration.requiredRole = anyOf;
        return descriptor;
    }
    return apidec;
}
exports.RequiredRole = RequiredRole;
function Workflow(config = {}) {
    function decorator(target, propertyKey, inDescriptor) {
        const { descriptor, registration } = registerAndWrapFunction(target, propertyKey, inDescriptor);
        registration.workflowConfig = config;
        return descriptor;
    }
    return decorator;
}
exports.Workflow = Workflow;
function Transaction(config = {}) {
    function decorator(target, propertyKey, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    inDescriptor) {
        const { descriptor, registration } = registerAndWrapFunction(target, propertyKey, inDescriptor);
        registration.txnConfig = config;
        return descriptor;
    }
    return decorator;
}
exports.Transaction = Transaction;
function StoredProcedure(config = {}) {
    function decorator(target, propertyKey, inDescriptor) {
        const { descriptor, registration } = registerAndWrapFunction(target, propertyKey, inDescriptor);
        registration.procConfig = config;
        return descriptor;
    }
    return decorator;
}
exports.StoredProcedure = StoredProcedure;
function Step(config = {}) {
    function decorator(target, propertyKey, inDescriptor) {
        const { descriptor, registration } = registerAndWrapFunction(target, propertyKey, inDescriptor);
        registration.commConfig = config;
        return descriptor;
    }
    return decorator;
}
exports.Step = Step;
// eslint-disable-next-line @typescript-eslint/ban-types
function OrmEntities(entities = []) {
    function clsdec(ctor) {
        const clsreg = getOrCreateClassRegistration(ctor);
        clsreg.ormEntities = entities;
    }
    return clsdec;
}
exports.OrmEntities = OrmEntities;
function DBOSInitializer() {
    function decorator(target, propertyKey, inDescriptor) {
        const { descriptor, registration } = registerAndWrapFunction(target, propertyKey, inDescriptor);
        registration.init = true;
        return descriptor;
    }
    return decorator;
}
exports.DBOSInitializer = DBOSInitializer;
// For future use with Deploy
function DBOSDeploy() {
    function decorator(target, propertyKey, inDescriptor) {
        const { descriptor, registration } = registerAndWrapFunction(target, propertyKey, inDescriptor);
        registration.init = true;
        return descriptor;
    }
    return decorator;
}
exports.DBOSDeploy = DBOSDeploy;
//# sourceMappingURL=decorators.js.map