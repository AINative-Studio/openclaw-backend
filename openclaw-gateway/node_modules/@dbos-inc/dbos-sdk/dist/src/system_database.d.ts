import { DBOSNull } from "./dbos-executor";
import { Pool, PoolClient, PoolConfig } from "pg";
import { GetWorkflowQueueInput, GetWorkflowQueueOutput, GetWorkflowsInput, GetWorkflowsOutput, StatusString, WorkflowStatus } from "./workflow";
import { HTTPRequest } from "./context";
import { GlobalLogger as Logger } from "./telemetry/logs";
import { Knex } from "knex";
import { WorkflowQueue } from "./wfqueue";
import { DBOSEventReceiverQuery, DBOSEventReceiverState } from "./eventreceiver";
export interface SystemDatabase {
    init(): Promise<void>;
    destroy(): Promise<void>;
    checkWorkflowOutput<R>(workflowUUID: string): Promise<DBOSNull | R>;
    initWorkflowStatus<T extends any[]>(bufferedStatus: WorkflowStatusInternal, args: T): Promise<T>;
    bufferWorkflowOutput(workflowUUID: string, status: WorkflowStatusInternal): void;
    flushWorkflowSystemBuffers(): Promise<void>;
    recordWorkflowError(workflowUUID: string, status: WorkflowStatusInternal): Promise<void>;
    getPendingWorkflows(executorID: string): Promise<Array<string>>;
    bufferWorkflowInputs<T extends any[]>(workflowUUID: string, args: T): void;
    getWorkflowInputs<T extends any[]>(workflowUUID: string): Promise<T | null>;
    checkOperationOutput<R>(workflowUUID: string, functionID: number): Promise<DBOSNull | R>;
    recordOperationOutput<R>(workflowUUID: string, functionID: number, output: R): Promise<void>;
    recordOperationError(workflowUUID: string, functionID: number, error: Error): Promise<void>;
    getWorkflowStatus(workflowUUID: string, callerUUID?: string, functionID?: number): Promise<WorkflowStatus | null>;
    getWorkflowResult<R>(workflowUUID: string): Promise<R>;
    setWorkflowStatus(workflowUUID: string, status: typeof StatusString[keyof typeof StatusString], resetRecoveryAttempts: boolean): Promise<void>;
    enqueueWorkflow(workflowId: string, queue: WorkflowQueue): Promise<void>;
    dequeueWorkflow(workflowId: string, queue: WorkflowQueue): Promise<void>;
    findAndMarkStartableWorkflows(queue: WorkflowQueue): Promise<string[]>;
    sleepms(workflowUUID: string, functionID: number, duration: number): Promise<void>;
    send<T>(workflowUUID: string, functionID: number, destinationUUID: string, message: T, topic?: string): Promise<void>;
    recv<T>(workflowUUID: string, functionID: number, timeoutFunctionID: number, topic?: string, timeoutSeconds?: number): Promise<T | null>;
    setEvent<T>(workflowUUID: string, functionID: number, key: string, value: T): Promise<void>;
    getEvent<T>(workflowUUID: string, key: string, timeoutSeconds: number, callerWorkflow?: {
        workflowUUID: string;
        functionID: number;
        timeoutFunctionID: number;
    }): Promise<T | null>;
    getEventDispatchState(service: string, workflowFnName: string, key: string): Promise<DBOSEventReceiverState | undefined>;
    queryEventDispatchState(query: DBOSEventReceiverQuery): Promise<DBOSEventReceiverState[]>;
    upsertEventDispatchState(state: DBOSEventReceiverState): Promise<DBOSEventReceiverState>;
    getWorkflows(input: GetWorkflowsInput): Promise<GetWorkflowsOutput>;
    getWorkflowQueue(input: GetWorkflowQueueInput): Promise<GetWorkflowQueueOutput>;
}
export interface WorkflowStatusInternal {
    workflowUUID: string;
    status: string;
    name: string;
    className: string;
    configName: string;
    queueName?: string;
    authenticatedUser: string;
    output: unknown;
    error: string;
    assumedRole: string;
    authenticatedRoles: string[];
    request: HTTPRequest;
    executorID: string;
    applicationVersion: string;
    applicationID: string;
    createdAt: number;
    maxRetries: number;
    recovery: boolean;
}
export interface ExistenceCheck {
    exists: boolean;
}
export declare function migrateSystemDatabase(systemPoolConfig: PoolConfig): Promise<void>;
export declare class PostgresSystemDatabase implements SystemDatabase {
    readonly pgPoolConfig: PoolConfig;
    readonly systemDatabaseName: string;
    readonly logger: Logger;
    readonly pool: Pool;
    readonly systemPoolConfig: PoolConfig;
    readonly knexDB: Knex;
    notificationsClient: PoolClient | null;
    readonly notificationsMap: Record<string, () => void>;
    readonly workflowEventsMap: Record<string, () => void>;
    readonly workflowStatusBuffer: Map<string, WorkflowStatusInternal>;
    readonly workflowInputsBuffer: Map<string, any[]>;
    readonly flushBatchSize = 100;
    static readonly connectionTimeoutMillis = 10000;
    constructor(pgPoolConfig: PoolConfig, systemDatabaseName: string, logger: Logger);
    init(): Promise<void>;
    destroy(): Promise<void>;
    checkWorkflowOutput<R>(workflowUUID: string): Promise<DBOSNull | R>;
    initWorkflowStatus<T extends any[]>(initStatus: WorkflowStatusInternal, args: T): Promise<T>;
    bufferWorkflowOutput(workflowUUID: string, status: WorkflowStatusInternal): void;
    /**
     * Flush the workflow output buffer and the input buffer to the database.
     */
    flushWorkflowSystemBuffers(): Promise<void>;
    flushWorkflowStatusBuffer(): Promise<void>;
    recordWorkflowError(workflowUUID: string, status: WorkflowStatusInternal): Promise<void>;
    getPendingWorkflows(executorID: string): Promise<Array<string>>;
    bufferWorkflowInputs<T extends any[]>(workflowUUID: string, args: T): void;
    flushWorkflowInputsBuffer(): Promise<void>;
    getWorkflowInputs<T extends any[]>(workflowUUID: string): Promise<T | null>;
    checkOperationOutput<R>(workflowUUID: string, functionID: number): Promise<DBOSNull | R>;
    recordOperationOutput<R>(workflowUUID: string, functionID: number, output: R): Promise<void>;
    recordOperationError(workflowUUID: string, functionID: number, error: Error): Promise<void>;
    /**
     *  Guard the operation, throwing an error if a conflicting execution is detected.
     */
    recordNotificationOutput<R>(client: PoolClient, workflowUUID: string, functionID: number, output: R): Promise<void>;
    sleepms(workflowUUID: string, functionID: number, durationMS: number): Promise<void>;
    readonly nullTopic = "__null__topic__";
    send<T>(workflowUUID: string, functionID: number, destinationUUID: string, message: T, topic?: string): Promise<void>;
    recv<T>(workflowUUID: string, functionID: number, timeoutFunctionID: number, topic?: string, timeoutSeconds?: number): Promise<T | null>;
    setEvent<T>(workflowUUID: string, functionID: number, key: string, message: T): Promise<void>;
    getEvent<T>(workflowUUID: string, key: string, timeoutSeconds: number, callerWorkflow?: {
        workflowUUID: string;
        functionID: number;
        timeoutFunctionID: number;
    }): Promise<T | null>;
    setWorkflowStatus(workflowUUID: string, status: typeof StatusString[keyof typeof StatusString], resetRecoveryAttempts: boolean): Promise<void>;
    getWorkflowStatus(workflowUUID: string, callerUUID?: string, functionID?: number): Promise<WorkflowStatus | null>;
    getWorkflowResult<R>(workflowUUID: string): Promise<R>;
    /**
     * A background process that listens for notifications from Postgres then signals the appropriate
     * workflow listener by resolving its promise.
     */
    listenForNotifications(): Promise<void>;
    getEventDispatchState(svc: string, wfn: string, key: string): Promise<DBOSEventReceiverState | undefined>;
    queryEventDispatchState(input: DBOSEventReceiverQuery): Promise<DBOSEventReceiverState[]>;
    upsertEventDispatchState(state: DBOSEventReceiverState): Promise<DBOSEventReceiverState>;
    getWorkflows(input: GetWorkflowsInput): Promise<GetWorkflowsOutput>;
    getWorkflowQueue(input: GetWorkflowQueueInput): Promise<GetWorkflowQueueOutput>;
    enqueueWorkflow(workflowId: string, queue: WorkflowQueue): Promise<void>;
    dequeueWorkflow(workflowId: string, queue: WorkflowQueue): Promise<void>;
    findAndMarkStartableWorkflows(queue: WorkflowQueue): Promise<string[]>;
}
//# sourceMappingURL=system_database.d.ts.map