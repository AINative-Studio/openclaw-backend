"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkflowContextDebug = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const dbos_executor_1 = require("../dbos-executor");
const transaction_1 = require("../transaction");
const error_1 = require("../error");
const serialize_error_1 = require("serialize-error");
const context_1 = require("../context");
const decorators_1 = require("../decorators");
const utils_1 = require("../utils");
const procedure_1 = require("../procedure");
const node_assert_1 = __importDefault(require("node:assert"));
/**
 * Context used for debugging a workflow
 */
class WorkflowContextDebug extends context_1.DBOSContextImpl {
    workflowConfig;
    functionID = 0;
    #dbosExec;
    isTempWorkflow;
    constructor(dbosExec, parentCtx, workflowUUID, workflowConfig, workflowName) {
        const span = dbosExec.tracer.startSpan(workflowName, {
            operationUUID: workflowUUID,
            operationType: dbos_executor_1.OperationType.WORKFLOW,
            authenticatedUser: parentCtx?.authenticatedUser ?? "",
            authenticatedRoles: parentCtx?.authenticatedRoles ?? [],
            assumedRole: parentCtx?.assumedRole ?? "",
        }, parentCtx?.span);
        super(workflowName, span, dbosExec.logger, parentCtx);
        this.workflowConfig = workflowConfig;
        this.workflowUUID = workflowUUID;
        this.#dbosExec = dbosExec;
        this.isTempWorkflow = dbos_executor_1.DBOSExecutor.tempWorkflowName === workflowName;
        this.applicationConfig = dbosExec.config.application;
    }
    functionIDGetIncrement() {
        return this.functionID++;
    }
    invoke(object) {
        if (typeof object === 'function') {
            const ops = (0, decorators_1.getRegisteredOperations)(object);
            const proxy = {};
            for (const op of ops) {
                proxy[op.name] = op.txnConfig
                    ? (...args) => this.transaction(op.registeredFunction, null, ...args)
                    : op.commConfig
                        ? (...args) => this.external(op.registeredFunction, null, ...args)
                        : op.procConfig
                            ? (...args) => this.procedure(op.registeredFunction, ...args)
                            : undefined;
            }
            return proxy;
        }
        else {
            const targetInst = object;
            const ops = (0, decorators_1.getRegisteredOperations)(targetInst);
            const proxy = {};
            for (const op of ops) {
                proxy[op.name] = op.txnConfig
                    ? (...args) => this.transaction(op.registeredFunction, targetInst, ...args)
                    : op.commConfig
                        ? (...args) => this.external(op.registeredFunction, targetInst, ...args)
                        : undefined;
            }
            return proxy;
        }
    }
    async #checkExecution(queryFunc, funcID) {
        // Note: we read the recorded snapshot and transaction ID!
        const query = "SELECT output, error, txn_snapshot, txn_id FROM dbos.transaction_outputs WHERE workflow_uuid=$1 AND function_id=$2";
        const rows = await queryFunc(query, [this.workflowUUID, funcID]);
        if (rows.length === 0 || rows.length > 1) {
            this.logger.error("Unexpected! This should never happen during debug. Found incorrect rows for transaction output.  Returned rows: " + rows.toString() + `. WorkflowUUID ${this.workflowUUID}, function ID ${funcID}`);
            throw new error_1.DBOSDebuggerError(`This should never happen during debug. Found incorrect rows for transaction output. Returned ${rows.length} rows: ` + rows.toString());
        }
        if (utils_1.DBOSJSON.parse(rows[0].error) !== null) {
            return (0, serialize_error_1.deserializeError)(utils_1.DBOSJSON.parse(rows[0].error));
        }
        const res = {
            output: utils_1.DBOSJSON.parse(rows[0].output),
            txn_snapshot: rows[0].txn_snapshot,
            txn_id: rows[0].txn_id,
        };
        if (this.#dbosExec.debugProxy) {
            // Send a signal to the debug proxy.
            await queryFunc(`--proxy:${res.txn_id ?? ''}:${res.txn_snapshot}`, []);
        }
        return res;
    }
    async checkTxExecution(client, funcID) {
        const func = (sql, args) => this.#dbosExec.userDatabase.queryWithClient(client, sql, ...args);
        return this.#checkExecution(func, funcID);
    }
    async checkProcExecution(client, funcID) {
        const func = (sql, args) => client.query(sql, args).then(v => v.rows);
        return this.#checkExecution(func, funcID);
    }
    /**
     * Execute a transactional function in debug mode.
     * If a debug proxy is provided, it connects to a debug proxy and everything should be read-only.
     */
    async transaction(txn, clsinst, ...args) {
        const txnInfo = this.#dbosExec.getTransactionInfo(txn);
        if (txnInfo === undefined) {
            throw new error_1.DBOSDebuggerError(`Transaction ${txn.name} not registered!`);
        }
        // const readOnly = true; // TODO: eventually, this transaction must be read-only.
        const funcID = this.functionIDGetIncrement();
        const span = this.#dbosExec.tracer.startSpan(txn.name, {
            operationUUID: this.workflowUUID,
            operationType: dbos_executor_1.OperationType.TRANSACTION,
            authenticatedUser: this.authenticatedUser,
            authenticatedRoles: this.authenticatedRoles,
            assumedRole: this.assumedRole,
            readOnly: txnInfo.config.readOnly ?? false, // For now doing as in src/workflow.ts:272
            isolationLevel: txnInfo.config.isolationLevel,
        }, this.span);
        let check;
        const wrappedTransaction = async (client) => {
            // Original result must exist during replay.
            const tCtxt = new transaction_1.TransactionContextImpl(this.#dbosExec.userDatabase.getName(), client, this, span, this.#dbosExec.logger, funcID, txn.name);
            check = await this.checkTxExecution(client, funcID);
            if (check instanceof Error) {
                if (this.#dbosExec.debugProxy) {
                    this.logger.warn(`original transaction ${txn.name} failed with error: ${check.message}`);
                }
                else {
                    throw check; // In direct mode, directly throw the error.
                }
            }
            if (!this.#dbosExec.debugProxy) {
                // Direct mode skips execution and return the recorded result.
                return check.output;
            }
            // If we have a proxy, then execute the user's transaction.
            let cresult;
            await (0, context_1.runWithTransactionContext)(tCtxt, async () => {
                cresult = await txn.call(clsinst, tCtxt, ...args);
            });
            const result = cresult;
            return result;
        };
        let result;
        try {
            result = await this.#dbosExec.userDatabase.transaction(wrappedTransaction, txnInfo.config);
        }
        catch (e) {
            result = e;
        }
        check = check;
        result = result;
        if (check instanceof Error) {
            throw check;
        }
        // If returned nothing and the recorded value is also null/undefined, we just return it
        if (result === undefined && !check.output) {
            return result;
        }
        if (utils_1.DBOSJSON.stringify(check.output) !== utils_1.DBOSJSON.stringify(result)) {
            this.logger.error(`Detected different transaction output than the original one!\n Result: ${utils_1.DBOSJSON.stringify(result)}\n Original: ${utils_1.DBOSJSON.stringify(check.output)}`);
        }
        return check.output; // Always return the recorded result.
    }
    async procedure(proc, ...args) {
        const procInfo = this.#dbosExec.getProcedureInfo(proc);
        if (procInfo === undefined) {
            throw new error_1.DBOSDebuggerError(proc.name);
        }
        const funcId = this.functionIDGetIncrement();
        const span = this.#dbosExec.tracer.startSpan(proc.name, {
            operationUUID: this.workflowUUID,
            operationType: dbos_executor_1.OperationType.PROCEDURE,
            authenticatedUser: this.authenticatedUser,
            assumedRole: this.assumedRole,
            authenticatedRoles: this.authenticatedRoles,
            readOnly: procInfo.config.readOnly ?? false,
            isolationLevel: procInfo.config.isolationLevel ?? transaction_1.IsolationLevel.Serializable,
        }, this.span);
        let check;
        const wrappedProcedure = async (client) => {
            check = await this.checkProcExecution(client, funcId);
            const procCtxt = new procedure_1.StoredProcedureContextImpl(client, this, span, this.#dbosExec.logger, proc.name);
            if (check instanceof Error) {
                if (this.#dbosExec.debugProxy) {
                    this.logger.warn(`original procedure ${proc.name} failed with error: ${check.message}`);
                }
                else {
                    throw check; // In direct mode, directly throw the error.
                }
            }
            if (!this.#dbosExec.debugProxy) {
                // Direct mode skips execution and return the recorded result.
                return check.output;
            }
            // If we have a proxy, then execute the user's transaction.
            const result = await proc(procCtxt, ...args);
            return result;
        };
        let result;
        try {
            result = await this.#dbosExec.executeProcedure(wrappedProcedure, procInfo.config);
        }
        catch (e) {
            result = e;
        }
        check = check;
        result = result;
        if (check instanceof Error) {
            throw check;
        }
        // If returned nothing and the recorded value is also null/undefined, we just return it
        if (result === undefined && !check.output) {
            return result;
        }
        try {
            node_assert_1.default.deepStrictEqual(result, check.output);
        }
        catch {
            this.logger.error(`Detected different transaction output than the original one!\n Result: ${JSON.stringify(result)}\n Original: ${JSON.stringify(check.output)}`);
        }
        return check.output; // Always return the recorded result.
    }
    async external(stepFn, _clsinst, ..._args) {
        const commConfig = this.#dbosExec.getStepInfo(stepFn);
        if (commConfig === undefined) {
            throw new error_1.DBOSDebuggerError(`Step ${stepFn.name} not registered!`);
        }
        const funcID = this.functionIDGetIncrement();
        // FIXME: we do not create a span for the replay step. Do we want to?
        // Original result must exist during replay.
        const check = await this.#dbosExec.systemDatabase.checkOperationOutput(this.workflowUUID, funcID);
        if (check === dbos_executor_1.dbosNull) {
            throw new error_1.DBOSDebuggerError(`Cannot find recorded step output for ${stepFn.name}. Shouldn't happen in debug mode!`);
        }
        this.logger.debug("Use recorded step output.");
        return check;
    }
    // Invoke the debugWorkflow() function instead.
    async startChildWorkflow(wf, ...args) {
        const funcId = this.functionIDGetIncrement();
        const childUUID = this.workflowUUID + "-" + funcId;
        return this.#dbosExec.debugWorkflow(wf, { parentCtx: this, workflowUUID: childUUID }, this.workflowUUID, funcId, ...args);
    }
    async invokeChildWorkflow(wf, ...args) {
        return this.startChildWorkflow(wf, ...args).then((handle) => handle.getResult());
    }
    /**
     * Generate a proxy object for the provided class that wraps direct calls (i.e. OpClass.someMethod(param))
     * to use WorkflowContext.Transaction(OpClass.someMethod, param);
     */
    proxyInvokeWF(object, workflowUUID, asyncWf, configuredInstance, queue) {
        const ops = (0, decorators_1.getRegisteredOperations)(object);
        const proxy = {};
        const funcId = this.functionIDGetIncrement();
        const childUUID = workflowUUID || (this.workflowUUID + "-" + funcId);
        const params = { workflowUUID: childUUID, parentCtx: this, configuredInstance, queueName: queue?.name };
        for (const op of ops) {
            if (asyncWf) {
                proxy[op.name] = op.workflowConfig
                    ? (...args) => this.#dbosExec.debugWorkflow(op.registeredFunction, params, this.workflowUUID, funcId, ...args)
                    : undefined;
            }
            else {
                proxy[op.name] = op.workflowConfig
                    ? (...args) => this.#dbosExec.debugWorkflow(op.registeredFunction, params, this.workflowUUID, funcId, ...args)
                        .then((handle) => handle.getResult())
                    : undefined;
            }
        }
        return proxy;
    }
    startWorkflow(target, workflowUUID, queue) {
        if (typeof target === 'function') {
            return this.proxyInvokeWF(target, workflowUUID, true, null, queue);
        }
        else {
            return this.proxyInvokeWF(target, workflowUUID, true, target, queue);
        }
    }
    invokeWorkflow(target, workflowUUID) {
        if (typeof target === 'function') {
            return this.proxyInvokeWF(target, workflowUUID, false, null);
        }
        else {
            return this.proxyInvokeWF(target, workflowUUID, false, target);
        }
    }
    async childWorkflow(wf, ...args) {
        return this.startChildWorkflow(wf, ...args);
    }
    async send(_destinationUUID, _message, _topic) {
        const functionID = this.functionIDGetIncrement();
        // Original result must exist during replay.
        const check = await this.#dbosExec.systemDatabase.checkOperationOutput(this.workflowUUID, functionID);
        if (check === dbos_executor_1.dbosNull) {
            throw new error_1.DBOSDebuggerError(`Cannot find recorded send. Shouldn't happen in debug mode!`);
        }
        this.logger.debug("Use recorded send output.");
        return;
    }
    async recv(_topic, _timeoutSeconds) {
        const functionID = this.functionIDGetIncrement();
        //Increment once more to account for the timeoutFunctionID created by workflow
        this.functionIDGetIncrement();
        // Original result must exist during replay.
        const check = await this.#dbosExec.systemDatabase.checkOperationOutput(this.workflowUUID, functionID);
        if (check === dbos_executor_1.dbosNull) {
            throw new error_1.DBOSDebuggerError(`Cannot find recorded recv. Shouldn't happen in debug mode!`);
        }
        this.logger.debug("Use recorded recv output.");
        return check;
    }
    async setEvent(_key, _value) {
        const functionID = this.functionIDGetIncrement();
        // Original result must exist during replay.
        const check = await this.#dbosExec.systemDatabase.checkOperationOutput(this.workflowUUID, functionID);
        if (check === dbos_executor_1.dbosNull) {
            throw new error_1.DBOSDebuggerError(`Cannot find recorded setEvent. Shouldn't happen in debug mode!`);
        }
        this.logger.debug("Use recorded setEvent output.");
    }
    async getEvent(_workflowUUID, _key, _timeoutSeconds) {
        const functionID = this.functionIDGetIncrement();
        //take into account the extra functionID increment from workflow
        this.functionIDGetIncrement();
        // Original result must exist during replay.
        const check = await this.#dbosExec.systemDatabase.checkOperationOutput(this.workflowUUID, functionID);
        if (check === dbos_executor_1.dbosNull) {
            throw new error_1.DBOSDebuggerError(`Cannot find recorded getEvent. Shouldn't happen in debug mode!`);
        }
        this.logger.debug("Use recorded getEvent output.");
        return check;
    }
    retrieveWorkflow(targetUUID) {
        // TODO: write a proper test for this.
        const functionID = this.functionIDGetIncrement();
        return new RetrievedHandleDebug(this.#dbosExec.systemDatabase, targetUUID, this.workflowUUID, functionID);
    }
    async sleepms(_) {
        // Need to increment function ID for faithful replay.
        this.functionIDGetIncrement();
        return Promise.resolve();
    }
    async sleep(s) {
        return this.sleepms(s * 1000);
    }
}
exports.WorkflowContextDebug = WorkflowContextDebug;
/**
 * The handle returned when retrieving a workflow with Debug workflow's retrieve
 */
class RetrievedHandleDebug {
    systemDatabase;
    workflowUUID;
    callerUUID;
    callerFunctionID;
    constructor(systemDatabase, workflowUUID, callerUUID, callerFunctionID) {
        this.systemDatabase = systemDatabase;
        this.workflowUUID = workflowUUID;
        this.callerUUID = callerUUID;
        this.callerFunctionID = callerFunctionID;
    }
    getWorkflowUUID() {
        return this.workflowUUID;
    }
    async getStatus() {
        // Must use original result.
        const check = await this.systemDatabase.checkOperationOutput(this.callerUUID, this.callerFunctionID);
        if (check === dbos_executor_1.dbosNull) {
            throw new error_1.DBOSDebuggerError(`Cannot find recorded workflow status. Shouldn't happen in debug mode!`);
        }
        return check;
    }
    async getResult() {
        return await this.systemDatabase.getWorkflowResult(this.workflowUUID);
    }
    async getWorkflowInputs() {
        return await this.systemDatabase.getWorkflowInputs(this.workflowUUID);
    }
}
//# sourceMappingURL=debug_workflow.js.map