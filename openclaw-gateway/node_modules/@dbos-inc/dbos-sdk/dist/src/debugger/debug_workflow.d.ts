import { DBOSExecutor } from "../dbos-executor";
import { Transaction } from "../transaction";
import { StepFunction } from "../step";
import { UserDatabaseClient } from "../user_database";
import { DBOSContextImpl } from "../context";
import { ConfiguredInstance } from "../decorators";
import { WFInvokeFuncs, WfInvokeWfs, WfInvokeWfsAsync, Workflow, WorkflowConfig, WorkflowContext, WorkflowHandle } from "../workflow";
import { InvokeFuncsInst } from "../httpServer/handler";
import { StoredProcedure } from "../procedure";
import { PoolClient } from "pg";
import { WorkflowQueue } from "../wfqueue";
interface RecordedResult<R> {
    output: R;
    txn_snapshot: string;
    txn_id: string;
}
/**
 * Context used for debugging a workflow
 */
export declare class WorkflowContextDebug extends DBOSContextImpl implements WorkflowContext {
    #private;
    readonly workflowConfig: WorkflowConfig;
    functionID: number;
    readonly isTempWorkflow: boolean;
    constructor(dbosExec: DBOSExecutor, parentCtx: DBOSContextImpl | undefined, workflowUUID: string, workflowConfig: WorkflowConfig, workflowName: string);
    functionIDGetIncrement(): number;
    invoke<T extends object>(object: T | ConfiguredInstance): WFInvokeFuncs<T> | InvokeFuncsInst<T>;
    checkTxExecution<R>(client: UserDatabaseClient, funcID: number): Promise<RecordedResult<R> | Error>;
    checkProcExecution<R>(client: PoolClient, funcID: number): Promise<RecordedResult<R> | Error>;
    /**
     * Execute a transactional function in debug mode.
     * If a debug proxy is provided, it connects to a debug proxy and everything should be read-only.
     */
    transaction<T extends unknown[], R>(txn: Transaction<T, R>, clsinst: ConfiguredInstance | null, ...args: T): Promise<R>;
    procedure<R>(proc: StoredProcedure<R>, ...args: unknown[]): Promise<R>;
    external<T extends unknown[], R>(stepFn: StepFunction<T, R>, _clsinst: ConfiguredInstance | null, ..._args: T): Promise<R>;
    startChildWorkflow<T extends any[], R>(wf: Workflow<T, R>, ...args: T): Promise<WorkflowHandle<R>>;
    invokeChildWorkflow<T extends unknown[], R>(wf: Workflow<T, R>, ...args: T): Promise<R>;
    /**
     * Generate a proxy object for the provided class that wraps direct calls (i.e. OpClass.someMethod(param))
     * to use WorkflowContext.Transaction(OpClass.someMethod, param);
     */
    proxyInvokeWF<T extends object>(object: T, workflowUUID: string | undefined, asyncWf: boolean, configuredInstance: ConfiguredInstance | null, queue?: WorkflowQueue): WfInvokeWfsAsync<T>;
    startWorkflow<T extends object>(target: T, workflowUUID?: string, queue?: WorkflowQueue): WfInvokeWfsAsync<T>;
    invokeWorkflow<T extends object>(target: T, workflowUUID?: string): WfInvokeWfs<T>;
    childWorkflow<T extends any[], R>(wf: Workflow<T, R>, ...args: T): Promise<WorkflowHandle<R>>;
    send<T>(_destinationUUID: string, _message: T, _topic?: string | undefined): Promise<void>;
    recv<T>(_topic?: string | undefined, _timeoutSeconds?: number | undefined): Promise<T | null>;
    setEvent<T>(_key: string, _value: T): Promise<void>;
    getEvent<T>(_workflowUUID: string, _key: string, _timeoutSeconds?: number | undefined): Promise<T | null>;
    retrieveWorkflow<R>(targetUUID: string): WorkflowHandle<R>;
    sleepms(_: number): Promise<void>;
    sleep(s: number): Promise<void>;
}
export {};
//# sourceMappingURL=debug_workflow.d.ts.map