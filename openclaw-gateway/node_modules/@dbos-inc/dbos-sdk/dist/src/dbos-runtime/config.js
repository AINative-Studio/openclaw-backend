"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseConfigFile = exports.constructPoolConfig = exports.retrieveApplicationName = exports.writeConfigFile = exports.loadConfigFile = exports.substituteEnvVars = exports.dbosConfigFilePath = void 0;
const error_1 = require("../error");
const utils_1 = require("../utils");
const yaml_1 = __importDefault(require("yaml"));
const runtime_1 = require("./runtime");
const user_database_1 = require("../user_database");
const fs_1 = require("fs");
const ajv_1 = __importDefault(require("ajv"));
const path_1 = __importDefault(require("path"));
const validator_1 = __importDefault(require("validator"));
const fs_2 = __importDefault(require("fs"));
exports.dbosConfigFilePath = "dbos-config.yaml";
const dbosConfigSchemaPath = path_1.default.join((0, utils_1.findPackageRoot)(__dirname), 'dbos-config.schema.json');
const dbosConfigSchema = utils_1.DBOSJSON.parse((0, utils_1.readFileSync)(dbosConfigSchemaPath));
const ajv = new ajv_1.default({ allErrors: true, verbose: true });
/*
 * Substitute environment variables using a regex for matching.
 * Will find anything in curly braces.
 * TODO: Use a more robust solution.
 */
function substituteEnvVars(content) {
    const regex = /\${([^}]+)}/g; // Regex to match ${VAR_NAME} style placeholders
    return content.replace(regex, (_, g1) => {
        return process.env[g1] || '""'; // If the env variable is not set, return an empty string.
    });
}
exports.substituteEnvVars = substituteEnvVars;
/**
 * Loads config file as a ConfigFile.
 * @param {string} configFilePath - The path to the config file to be loaded.
 * @returns
 */
function loadConfigFile(configFilePath) {
    try {
        const configFileContent = (0, utils_1.readFileSync)(configFilePath);
        const interpolatedConfig = substituteEnvVars(configFileContent);
        const configFile = yaml_1.default.parse(interpolatedConfig);
        return configFile;
    }
    catch (e) {
        if (e instanceof Error) {
            throw new error_1.DBOSInitializationError(`Failed to load config from ${configFilePath}: ${e.message}`);
        }
        else {
            throw e;
        }
    }
}
exports.loadConfigFile = loadConfigFile;
/**
 * Writes a YAML.Document object to configFilePath.
 * @param {YAML.Document} configFile - The config file to be written.
 * @param {string} configFilePath - The path to the config file to be written to.
 */
function writeConfigFile(configFile, configFilePath) {
    try {
        const configFileContent = configFile.toString();
        (0, fs_1.writeFileSync)(configFilePath, configFileContent);
    }
    catch (e) {
        if (e instanceof Error) {
            throw new error_1.DBOSInitializationError(`Failed to write config to ${configFilePath}: ${e.message}`);
        }
        else {
            throw e;
        }
    }
}
exports.writeConfigFile = writeConfigFile;
function retrieveApplicationName(configFile) {
    let appName = configFile.name;
    if (appName !== undefined) {
        return appName;
    }
    const packageJson = JSON.parse(fs_2.default.readFileSync(path_1.default.join(process.cwd(), "package.json")).toString());
    appName = packageJson.name;
    if (appName === undefined) {
        throw new error_1.DBOSInitializationError("Error: cannot find a valid package.json file. Please run this command in an application root directory.");
    }
    return appName;
}
exports.retrieveApplicationName = retrieveApplicationName;
function constructPoolConfig(configFile) {
    let databaseName = configFile.database.app_db_name;
    if (databaseName === undefined) {
        const appName = retrieveApplicationName(configFile);
        databaseName = appName.toLowerCase().replaceAll("-", "_");
        if (databaseName.match(/^\d/)) {
            databaseName = "_" + databaseName; // Append an underscore if the name starts with a digit
        }
    }
    databaseName = configFile.database.local_suffix === true ? `${databaseName}_local` : databaseName;
    const poolConfig = {
        host: configFile.database.hostname,
        port: configFile.database.port,
        user: configFile.database.username,
        password: configFile.database.password,
        connectionTimeoutMillis: configFile.database.connectionTimeoutMillis || 3000,
        database: databaseName,
    };
    if (!poolConfig.database) {
        throw new error_1.DBOSInitializationError(`DBOS configuration (${exports.dbosConfigFilePath}) does not contain application database name`);
    }
    // Details on Postgres SSL/TLS modes: https://www.postgresql.org/docs/current/libpq-ssl.html#LIBPQ-SSL-PROTECTION
    if (configFile.database.ssl === false) {
        // If SSL is set to false, do not use TLS
        poolConfig.ssl = false;
    }
    else if (configFile.database.ssl_ca) {
        // If an SSL certificate is provided, connect to Postgres using TLS and verify the server certificate. (equivalent to verify-full)
        poolConfig.ssl = { ca: [(0, utils_1.readFileSync)(configFile.database.ssl_ca)], rejectUnauthorized: true };
    }
    else if (configFile.database.ssl === undefined && (poolConfig.host === "localhost" || poolConfig.host === "127.0.0.1")) {
        // For local development only, do not use TLS unless it is specifically asked for (to support Dockerized Postgres, which does not support SSL connections)
        poolConfig.ssl = false;
    }
    else {
        // Otherwise, connect to Postgres using TLS but do not verify the server certificate. (equivalent to require)
        poolConfig.ssl = { rejectUnauthorized: false };
    }
    return poolConfig;
}
exports.constructPoolConfig = constructPoolConfig;
function prettyPrintAjvErrors(validate) {
    return validate.errors.map(error => {
        let message = `Error: ${error.message}`;
        if (error.schemaPath)
            message += ` (schema path: ${error.schemaPath})`;
        if (error.params && error.keyword === 'additionalProperties') {
            message += `; the additional property '${error.params.additionalProperty}' is not allowed`;
        }
        if (error.data && error.keyword === 'not') {
            message += `; the value ${utils_1.DBOSJSON.stringify(error.data)} is not allowed for field ${error.instancePath}`;
        }
        return message;
    }).join(', ');
}
/*
 * Parse `dbosConfigFilePath` and return DBOSConfig and DBOSRuntimeConfig
 * Considers DBOSCLIStartOptions if provided, which takes precedence over config file
 * */
function parseConfigFile(cliOptions, useProxy = false) {
    if (cliOptions?.appDir) {
        process.chdir(cliOptions.appDir);
    }
    const configFilePath = cliOptions?.configfile ?? exports.dbosConfigFilePath;
    const configFile = loadConfigFile(configFilePath);
    if (!configFile) {
        throw new error_1.DBOSInitializationError(`DBOS configuration file ${configFilePath} is empty`);
    }
    // Database field must exist
    if (!configFile.database) {
        throw new error_1.DBOSInitializationError(`DBOS configuration (${configFilePath}) does not contain database config`);
    }
    // Check for the database password
    if (!configFile.database.password) {
        if (useProxy) {
            configFile.database.password = "PROXY-MODE"; // Assign a password if not set. We don't need password to authenticate with the local proxy.
        }
        else {
            const pgPassword = process.env.PGPASSWORD;
            if (pgPassword) {
                configFile.database.password = pgPassword;
            }
            else {
                throw new error_1.DBOSInitializationError(`DBOS configuration (${configFilePath}) does not contain database password`);
            }
        }
    }
    const schemaValidator = ajv.compile(dbosConfigSchema);
    if (!schemaValidator(configFile)) {
        const errorMessages = prettyPrintAjvErrors(schemaValidator);
        throw new error_1.DBOSInitializationError(`${configFilePath} failed schema validation. ${errorMessages}`);
    }
    if (configFile.language && configFile.language !== "node") {
        throw new error_1.DBOSInitializationError(`${configFilePath} specifies invalid language ${configFile.language}`);
    }
    /*******************************/
    /* Handle user database config */
    /*******************************/
    const poolConfig = constructPoolConfig(configFile);
    if (!isValidDBname(poolConfig.database)) {
        throw new error_1.DBOSInitializationError(`${configFilePath} specifies invalid app_db_name ${configFile.database.app_db_name}. Must be between 3 and 31 characters long and contain only lowercase letters, underscores, and digits (cannot begin with a digit).`);
    }
    /***************************/
    /* Handle telemetry config */
    /***************************/
    // Consider CLI --loglevel flag. A bit verbose because everything is optional.
    if (cliOptions?.loglevel) {
        if (!configFile.telemetry) {
            configFile.telemetry = { logs: { logLevel: cliOptions.loglevel } };
        }
        else if (!configFile.telemetry.logs) {
            configFile.telemetry.logs = { logLevel: cliOptions.loglevel };
        }
        else {
            configFile.telemetry.logs.logLevel = cliOptions.loglevel;
        }
    }
    /************************************/
    /* Build final DBOS configuration */
    /************************************/
    const dbosConfig = {
        poolConfig: poolConfig,
        userDbclient: configFile.database.app_db_client || user_database_1.UserDatabaseName.KNEX,
        telemetry: configFile.telemetry || undefined,
        system_database: configFile.database.sys_db_name ?? `${poolConfig.database}_dbos_sys`,
        application: configFile.application || undefined,
        env: configFile.env || {},
        http: configFile.http,
        appVersion: getAppVersion(cliOptions?.appVersion),
    };
    /*************************************/
    /* Build final runtime Configuration */
    /*************************************/
    const entrypoints = new Set();
    if (configFile.runtimeConfig?.entrypoints) {
        configFile.runtimeConfig.entrypoints.forEach((entry) => entrypoints.add(entry));
    }
    else {
        entrypoints.add(runtime_1.defaultEntryPoint);
    }
    const appPort = Number(cliOptions?.port) || Number(configFile.runtimeConfig?.port) || 3000;
    const runtimeConfig = {
        entrypoints: [...entrypoints],
        port: appPort,
        admin_port: Number(configFile.runtimeConfig?.admin_port) || appPort + 1,
        start: configFile.runtimeConfig?.start || [],
        setup: configFile.runtimeConfig?.setup || [],
    };
    return [dbosConfig, runtimeConfig];
}
exports.parseConfigFile = parseConfigFile;
function getAppVersion(appVersion) {
    if (typeof appVersion === "string") {
        return appVersion;
    }
    if (appVersion === false) {
        return undefined;
    }
    return process.env.DBOS__APPVERSION;
}
function isValidDBname(dbName) {
    if (dbName.length < 1 || dbName.length > 63) {
        return false;
    }
    if (dbName.match(/^\d/)) {
        // Cannot start with a digit
        return false;
    }
    return validator_1.default.matches(dbName, "^[a-z0-9_]+$");
}
//# sourceMappingURL=config.js.map