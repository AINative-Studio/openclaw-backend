#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runAndLog = void 0;
const runtime_1 = require("./runtime");
const config_1 = require("./config");
const commander_1 = require("commander");
const debug_1 = require("./debug");
const migrate_1 = require("./migrate");
const logs_1 = require("../telemetry/logs");
const collector_1 = require("../telemetry/collector");
const exporters_1 = require("../telemetry/exporters");
const configure_1 = require("./configure");
const workflow_management_1 = require("./workflow_management");
const __1 = require("..");
const node_process_1 = require("node:process");
const commands_1 = require("./commands");
const program = new commander_1.Command();
// eslint-disable-next-line @typescript-eslint/no-require-imports
const packageJson = require("../../../package.json");
program.version(packageJson.version);
program
    .command("start")
    .description("Start the server")
    .option("-p, --port <number>", "Specify the port number")
    .option("-l, --loglevel <string>", "Specify log level")
    .option("-c, --configfile <string>", "Specify the config file path (DEPRECATED)")
    .option("-d, --appDir <string>", "Specify the application root directory")
    .option("--app-version <string>", "override DBOS__APPVERSION environment variable")
    .option("--no-app-version", "ignore DBOS__APPVERSION environment variable")
    .action(async (options) => {
    if (options?.configfile) {
        console.warn("\x1b[33m%s\x1b[0m", "The --configfile option is deprecated. Please use --appDir instead.");
    }
    const [dbosConfig, runtimeConfig] = (0, config_1.parseConfigFile)(options);
    // If no start commands are provided, start the DBOS runtime
    if (runtimeConfig.start.length === 0) {
        const runtime = new runtime_1.DBOSRuntime(dbosConfig, runtimeConfig);
        await runtime.initAndStart();
    }
    else {
        const logger = getGlobalLogger(dbosConfig);
        for (const command of runtimeConfig.start) {
            try {
                const ret = await (0, commands_1.runCommand)(command, logger, options.appDir);
                if (ret !== 0) {
                    process.exit(ret);
                }
            }
            catch (e) {
                // We always reject the command with a return code
                process.exit(e);
            }
        }
    }
});
program
    .command("debug")
    .description("Debug a workflow")
    .option("-x, --proxy <string>", "Specify the time-travel debug proxy URL for debugging cloud traces")
    .requiredOption("-u, --uuid <string>", "Specify the workflow UUID to replay")
    .option("-l, --loglevel <string>", "Specify log level")
    .option("-c, --configfile <string>", "Specify the config file path (DEPRECATED)")
    .option("-d, --appDir <string>", "Specify the application root directory")
    .option('--app-version <string>', 'override DBOS__APPVERSION environment variable')
    .option('--no-app-version', 'ignore DBOS__APPVERSION environment variable')
    .action(async (options) => {
    const [dbosConfig, runtimeConfig] = (0, config_1.parseConfigFile)(options, options.proxy !== undefined);
    await (0, debug_1.debugWorkflow)(dbosConfig, runtimeConfig, options.uuid, options.proxy);
});
program
    .command('init')
    .description('Init a DBOS application')
    .option('-n, --appName <application-name>', 'Application name', 'dbos-hello-app')
    .action((_options) => {
    console.log("NOTE: This command has been removed in favor of `npx @dbos-inc/create` or `npm create @dbos-inc`");
});
program
    .command('configure')
    .alias('config')
    .option('-h, --host <string>', 'Specify your Postgres server hostname')
    .option('-p, --port <number>', 'Specify your Postgres server port')
    .option('-U, --username <number>', 'Specify your Postgres username')
    .action(async (options) => {
    await (0, configure_1.configure)(options.host, options.port, options.username);
});
program
    .command('migrate')
    .description("Perform a database migration")
    .action(async () => { await runAndLog(migrate_1.migrate); });
program
    .command('rollback')
    .action(async () => { await runAndLog(migrate_1.rollbackMigration); });
/////////////////////////
/* WORKFLOW MANAGEMENT */
/////////////////////////
const workflowCommands = program.command("workflow").alias("workflows").alias("wf").description("Manage DBOS workflows");
workflowCommands
    .command('list')
    .description('List workflows from your application')
    .option('-l, --limit <number>', 'Limit the results returned', "10")
    .option('-u, --user <string>', 'Retrieve workflows run by this user')
    .option('-s, --start-time <string>', 'Retrieve workflows starting after this timestamp (ISO 8601 format)')
    .option('-e, --end-time <string>', 'Retrieve workflows starting before this timestamp (ISO 8601 format)')
    .option('-S, --status <string>', 'Retrieve workflows with this status (PENDING, SUCCESS, ERROR, RETRIES_EXCEEDED, ENQUEUED, or CANCELLED)')
    .option('-v, --application-version <string>', 'Retrieve workflows with this application version')
    .option('--request', 'Retrieve workflow request information')
    .option("-d, --appDir <string>", "Specify the application root directory")
    .action(async (options) => {
    const [dbosConfig, _] = (0, config_1.parseConfigFile)(options);
    if (options.status && !Object.values(__1.StatusString).includes(options.status)) {
        console.error("Invalid status: ", options.status);
        (0, node_process_1.exit)(1);
    }
    const input = {
        limit: Number(options.limit),
        authenticatedUser: options.user,
        startTime: options.startTime,
        endTime: options.endTime,
        status: options.status,
        applicationVersion: options.applicationVersion,
    };
    const output = await (0, workflow_management_1.listWorkflows)(dbosConfig, input, options.request);
    console.log(JSON.stringify(output));
});
workflowCommands
    .command('get')
    .description('Retrieve the status of a workflow')
    .argument("<uuid>", "Target workflow UUID")
    .option("-d, --appDir <string>", "Specify the application root directory")
    .option('--request', 'Retrieve workflow request information')
    .action(async (uuid, options) => {
    const [dbosConfig, _] = (0, config_1.parseConfigFile)(options);
    const output = await (0, workflow_management_1.getWorkflow)(dbosConfig, uuid, options.request);
    console.log(JSON.stringify(output));
});
workflowCommands
    .command('cancel')
    .description('Cancel a workflow so it is no longer automatically retried or restarted')
    .argument("<uuid>", "Target workflow UUID")
    .option("-d, --appDir <string>", "Specify the application root directory")
    .action(async (uuid, options) => {
    const [dbosConfig, _] = (0, config_1.parseConfigFile)(options);
    await (0, workflow_management_1.cancelWorkflow)(dbosConfig, uuid);
});
workflowCommands
    .command('resume')
    .description('Resume a workflow from the last step it executed, keeping its UUID')
    .argument("<uuid>", "Target workflow UUID")
    .option("-d, --appDir <string>", "Specify the application root directory")
    .action(async (uuid, options) => {
    const [dbosConfig, runtimeConfig] = (0, config_1.parseConfigFile)(options);
    const output = await (0, workflow_management_1.reattemptWorkflow)(dbosConfig, runtimeConfig, uuid, false);
    console.log(`Workflow output: ${JSON.stringify(output)}`);
});
workflowCommands
    .command('restart')
    .description('Restart a workflow from the beginning with a new UUID')
    .argument("<uuid>", "Target workflow UUID")
    .option("-d, --appDir <string>", "Specify the application root directory")
    .action(async (uuid, options) => {
    const [dbosConfig, runtimeConfig] = (0, config_1.parseConfigFile)(options);
    const output = await (0, workflow_management_1.reattemptWorkflow)(dbosConfig, runtimeConfig, uuid, true);
    console.log(`Workflow output: ${JSON.stringify(output)}`);
});
/////////////
/* PARSING */
/////////////
program.parse(process.argv);
// If no arguments provided, display help by default
if (!process.argv.slice(2).length) {
    program.outputHelp();
}
//Takes an action function(configFile, logger) that returns a numeric exit code.
//If otel exporter is specified in configFile, adds it to the logger and flushes it after.
//If action throws, logs the exception and sets the exit code to 1.
//Finally, terminates the program with the exit code.
async function runAndLog(action) {
    let logger = new logs_1.GlobalLogger();
    const _ = (0, config_1.parseConfigFile)(); // Validate config file
    const configFile = (0, config_1.loadConfigFile)(config_1.dbosConfigFilePath);
    let terminate = undefined;
    if (configFile.telemetry?.OTLPExporter) {
        logger = new logs_1.GlobalLogger(new collector_1.TelemetryCollector(new exporters_1.TelemetryExporter(configFile.telemetry.OTLPExporter)), configFile.telemetry?.logs);
        terminate = (code) => {
            void logger.destroy().finally(() => {
                process.exit(code);
            });
        };
    }
    else {
        terminate = (code) => {
            process.exit(code);
        };
    }
    let returnCode = 1;
    try {
        returnCode = await action(configFile, logger);
    }
    catch (e) {
        logger.error(e);
    }
    terminate(returnCode);
}
exports.runAndLog = runAndLog;
function getGlobalLogger(configFile) {
    if (configFile.telemetry?.OTLPExporter) {
        return new logs_1.GlobalLogger(new collector_1.TelemetryCollector(new exporters_1.TelemetryExporter(configFile.telemetry.OTLPExporter)), configFile.telemetry?.logs);
    }
    return new logs_1.GlobalLogger();
}
//# sourceMappingURL=cli.js.map