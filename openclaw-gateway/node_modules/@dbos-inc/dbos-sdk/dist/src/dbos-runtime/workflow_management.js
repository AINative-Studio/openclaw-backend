"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reattemptWorkflow = exports.cancelWorkflow = exports.getWorkflow = exports.listWorkflows = void 0;
const winston_1 = require("winston");
const __1 = require("..");
const system_database_1 = require("../system_database");
const dbos_executor_1 = require("../dbos-executor");
const runtime_1 = require("./runtime");
async function listWorkflows(config, input, getRequest) {
    const systemDatabase = new system_database_1.PostgresSystemDatabase(config.poolConfig, config.system_database, (0, winston_1.createLogger)());
    const workflowUUIDs = (await systemDatabase.getWorkflows(input)).workflowUUIDs.reverse(); // Reverse so most recent entries are printed last
    const workflowInfos = await Promise.all(workflowUUIDs.map(async (i) => await getWorkflowInfo(systemDatabase, i, getRequest)));
    await systemDatabase.destroy();
    return workflowInfos;
}
exports.listWorkflows = listWorkflows;
async function getWorkflowInfo(systemDatabase, workflowUUID, getRequest) {
    const info = await systemDatabase.getWorkflowStatus(workflowUUID);
    info.workflowUUID = workflowUUID;
    if (info === null) {
        return {};
    }
    const input = await systemDatabase.getWorkflowInputs(workflowUUID);
    if (input !== null) {
        info.input = input;
    }
    if (info.status === __1.StatusString.SUCCESS) {
        const result = await systemDatabase.getWorkflowResult(workflowUUID);
        info.output = result;
    }
    else if (info.status === __1.StatusString.ERROR) {
        try {
            await systemDatabase.getWorkflowResult(workflowUUID);
        }
        catch (e) {
            info.error = e;
        }
    }
    if (!getRequest) {
        delete info.request;
    }
    return info;
}
async function getWorkflow(config, workflowUUID, getRequest) {
    const systemDatabase = new system_database_1.PostgresSystemDatabase(config.poolConfig, config.system_database, (0, winston_1.createLogger)());
    const info = await getWorkflowInfo(systemDatabase, workflowUUID, getRequest);
    await systemDatabase.destroy();
    return info;
}
exports.getWorkflow = getWorkflow;
// Cancelling a workflow prevents it from being automatically recovered, but active executions are not halted.
async function cancelWorkflow(config, workflowUUID) {
    const systemDatabase = new system_database_1.PostgresSystemDatabase(config.poolConfig, config.system_database, (0, winston_1.createLogger)());
    await systemDatabase.setWorkflowStatus(workflowUUID, __1.StatusString.CANCELLED, false);
    await systemDatabase.destroy();
}
exports.cancelWorkflow = cancelWorkflow;
async function reattemptWorkflow(config, runtimeConfig, workflowUUID, startNewWorkflow) {
    const dbosExec = new dbos_executor_1.DBOSExecutor(config);
    if (runtimeConfig !== null) {
        await runtime_1.DBOSRuntime.loadClasses(runtimeConfig.entrypoints);
    }
    await dbosExec.init();
    if (!startNewWorkflow) {
        await dbosExec.systemDatabase.setWorkflowStatus(workflowUUID, __1.StatusString.PENDING, true);
    }
    const handle = await dbosExec.executeWorkflowUUID(workflowUUID, startNewWorkflow);
    const output = await handle.getResult();
    await dbosExec.destroy();
    return output;
}
exports.reattemptWorkflow = reattemptWorkflow;
//# sourceMappingURL=workflow_management.js.map