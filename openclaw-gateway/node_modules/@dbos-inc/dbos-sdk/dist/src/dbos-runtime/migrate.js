"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rollbackMigration = exports.checkDatabaseExists = exports.migrate = void 0;
const child_process_1 = require("child_process");
const logs_1 = require("../telemetry/logs");
const config_1 = require("./config");
const pg_1 = require("pg");
const user_db_schema_1 = require("../../schemas/user_db_schema");
const system_database_1 = require("../system_database");
const user_database_1 = require("../user_database");
async function migrate(configFile, logger) {
    const userDBName = configFile.database.app_db_name;
    logger.info(`Starting migration: creating database ${userDBName} if it does not exist`);
    if (!(await checkDatabaseExists(configFile, logger))) {
        const postgresConfig = (0, config_1.constructPoolConfig)(configFile);
        const app_database = postgresConfig.database;
        postgresConfig.database = "postgres";
        const postgresClient = new pg_1.Client(postgresConfig);
        let connection_failed = true;
        try {
            await postgresClient.connect();
            connection_failed = false;
            await postgresClient.query(`CREATE DATABASE ${app_database}`);
        }
        catch (e) {
            if (e instanceof Error) {
                if (connection_failed) {
                    logger.error(`Error connecting to database ${postgresConfig.host}:${postgresConfig.port} with user ${postgresConfig.user}: ${e.message}`);
                }
                else {
                    logger.error(`Error creating database ${app_database}: ${e.message}`);
                }
            }
            else {
                logger.error(e);
            }
            return 1;
        }
        finally {
            await postgresClient.end();
        }
    }
    const migrationCommands = configFile.database.migrate;
    try {
        migrationCommands?.forEach((cmd) => {
            logger.info(`Executing migration command: ${cmd}`);
            const migrateCommandOutput = (0, child_process_1.execSync)(cmd, { encoding: 'utf-8' });
            logger.info(migrateCommandOutput.trimEnd());
        });
    }
    catch (e) {
        logMigrationError(e, logger, "Error running migration");
        return 1;
    }
    logger.info("Creating DBOS tables and system database.");
    try {
        await createDBOSTables(configFile);
    }
    catch (e) {
        if (e instanceof Error) {
            logger.error(`Error creating DBOS system database: ${e.message}`);
        }
        else {
            logger.error(e);
        }
        return 1;
    }
    logger.info("Migration successful!");
    return 0;
}
exports.migrate = migrate;
async function checkDatabaseExists(configFile, logger) {
    const pgUserConfig = (0, config_1.constructPoolConfig)(configFile);
    const pgUserClient = new pg_1.Client(pgUserConfig);
    try {
        await pgUserClient.connect(); // Try to establish a connection
        await pgUserClient.end();
        logger.info(`Database ${pgUserConfig.database} exists!`);
        return true; // If successful, return true
    }
    catch (error) {
        logger.info(`Database ${pgUserConfig.database} does not exist, creating...`);
        return false; // If connection fails, return false
    }
}
exports.checkDatabaseExists = checkDatabaseExists;
function rollbackMigration(configFile, logger) {
    logger.info("Starting Migration Rollback");
    let dbType = configFile.database.app_db_client;
    if (dbType === undefined) {
        dbType = "knex";
    }
    const rollbackcommands = configFile.database.rollback;
    try {
        rollbackcommands?.forEach((cmd) => {
            logger.info("Executing " + cmd);
            const migrateCommandOutput = (0, child_process_1.execSync)(cmd, { encoding: 'utf-8' });
            logger.info(migrateCommandOutput.trimEnd());
        });
    }
    catch (e) {
        logMigrationError(e, logger, "Error rolling back migration.");
        return 1;
    }
    return 0;
}
exports.rollbackMigration = rollbackMigration;
// Create DBOS system DB and tables.
// TODO: replace this with knex to manage schema.
async function createDBOSTables(configFile) {
    const logger = new logs_1.GlobalLogger();
    const userPoolConfig = (0, config_1.constructPoolConfig)(configFile);
    const systemPoolConfig = { ...userPoolConfig };
    systemPoolConfig.database = configFile.database.sys_db_name ?? `${userPoolConfig.database}_dbos_sys`;
    const pgUserClient = new pg_1.Client(userPoolConfig);
    await pgUserClient.connect();
    // Create DBOS table/schema in user DB.
    // Always check if the schema/table exists before creating it to avoid locks.
    const schemaExists = await pgUserClient.query(user_database_1.schemaExistsQuery);
    if (!schemaExists.rows[0].exists) {
        await pgUserClient.query(user_db_schema_1.createUserDBSchema);
    }
    const txnOutputTableExists = await pgUserClient.query(user_database_1.txnOutputTableExistsQuery);
    if (!txnOutputTableExists.rows[0].exists) {
        await pgUserClient.query(user_db_schema_1.userDBSchema);
    }
    const txnIndexExists = await pgUserClient.query(user_database_1.txnOutputIndexExistsQuery);
    if (!txnIndexExists.rows[0].exists) {
        await pgUserClient.query(user_db_schema_1.userDBIndex);
    }
    // Create the DBOS system database.
    const dbExists = await pgUserClient.query(`SELECT EXISTS (SELECT FROM pg_database WHERE datname = '${systemPoolConfig.database}')`);
    if (!dbExists.rows[0].exists) {
        await pgUserClient.query(`CREATE DATABASE ${systemPoolConfig.database}`);
    }
    // Load the DBOS system schema.
    const pgSystemClient = new pg_1.Client(systemPoolConfig);
    await pgSystemClient.connect();
    try {
        await (0, system_database_1.migrateSystemDatabase)(systemPoolConfig);
    }
    catch (e) {
        const tableExists = await pgSystemClient.query(`SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_schema = 'dbos' AND table_name = 'operation_outputs')`);
        if (tableExists.rows[0].exists) {
            // If the table has been created by someone else. Ignore the error.
            logger.warn(`System tables creation failed, may conflict with concurrent tasks: ${e.message}`);
        }
        else {
            throw e;
        }
    }
    finally {
        await pgSystemClient.end();
        await pgUserClient.end();
    }
}
//Test to determine if e can be treated as an ExecSyncError.
function isExecSyncError(e) {
    if (
    //Safeguard against NaN. NaN type is number but NaN !== NaN
    "pid" in e && (typeof e.pid === 'number' && e.pid === e.pid) &&
        "stdout" in e && (Buffer.isBuffer(e.stdout) || typeof e.stdout === 'string') &&
        "stderr" in e && (Buffer.isBuffer(e.stderr) || typeof e.stderr === 'string')) {
        return true;
    }
    return false;
}
function logMigrationError(e, logger, title) {
    logger.error(title);
    if (e instanceof Error && isExecSyncError(e)) {
        const stderr = e.stderr;
        if (e.stderr.length > 0) {
            logger.error(`Standard Error: ${stderr.toString().trim()}`);
        }
        const stdout = e.stdout;
        if (stdout.length > 0) {
            logger.error(`Standard Output: ${stdout.toString().trim()}`);
        }
        if (e.message) {
            logger.error(e.message);
        }
        if (e.error?.message) {
            logger.error(e.error?.message);
        }
    }
    else {
        logger.error(e);
    }
}
//# sourceMappingURL=migrate.js.map