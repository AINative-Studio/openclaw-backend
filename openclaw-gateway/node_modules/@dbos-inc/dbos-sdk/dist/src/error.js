"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DBOSInvalidWorkflowTransitionError = exports.DBOSExecutorNotInitializedError = exports.DBOSFailedSqlTransactionError = exports.DBOSDeadLetterQueueError = exports.DBOSFailLoadOperationsError = exports.DBOSNonExistentWorkflowError = exports.DBOSDebuggerError = exports.DBOSConfigKeyTypeError = exports.DBOSUndefinedDecoratorInputError = exports.DBOSNotAuthorizedError = exports.DBOSResponseError = exports.DBOSDataValidationError = exports.DBOSPostgresExporterError = exports.DBOSNotRegisteredError = exports.DBOSWorkflowConflictUUIDError = exports.DBOSTopicPermissionDeniedError = exports.DBOSInitializationError = exports.DBOSWorkflowPermissionDeniedError = exports.DBOSError = exports.isClientError = void 0;
const pg_1 = require("pg");
function formatPgDatabaseError(err) {
    let msg = "";
    if (err.severity) {
        msg = msg.concat(`severity: ${err.severity} \n`);
    }
    if (err.code) {
        msg = msg.concat(`code: ${err.code} \n`);
    }
    if (err.detail) {
        msg = msg.concat(`detail: ${err.detail} \n`);
    }
    if (err.hint) {
        msg = msg.concat(`hint: ${err.hint} \n`);
    }
    if (err.position) {
        msg = msg.concat(`position: ${err.position} \n`);
    }
    if (err.internalPosition) {
        msg = msg.concat(`internalPosition: ${err.internalPosition} \n`);
    }
    if (err.internalQuery) {
        msg = msg.concat(`internalQuery: ${err.internalQuery} \n`);
    }
    if (err.where) {
        msg = msg.concat(`where: ${err.where} \n`);
    }
    if (err.schema) {
        msg = msg.concat(`schema: ${err.schema} \n`);
    }
    if (err.table) {
        msg = msg.concat(`table: ${err.table} \n`);
    }
    if (err.column) {
        msg = msg.concat(`column: ${err.column} \n`);
    }
    if (err.dataType) {
        msg = msg.concat(`dataType: ${err.dataType} \n`);
    }
    if (err.constraint) {
        msg = msg.concat(`constraint: ${err.constraint} \n`);
    }
    if (err.file) {
        msg = msg.concat(`file: ${err.file} \n`);
    }
    if (err.line) {
        msg = msg.concat(`line: ${err.line} \n`);
    }
    return msg;
}
// Return if the error is caused by client request or by server internal.
function isClientError(dbosErrorCode) {
    return (dbosErrorCode === DataValidationError ||
        dbosErrorCode === WorkflowPermissionDeniedError ||
        dbosErrorCode === TopicPermissionDeniedError ||
        dbosErrorCode === ConflictingUUIDError ||
        dbosErrorCode === NotRegisteredError);
}
exports.isClientError = isClientError;
class DBOSError extends Error {
    dbosErrorCode;
    // TODO: define a better coding system.
    constructor(msg, dbosErrorCode = 1) {
        super(msg);
        this.dbosErrorCode = dbosErrorCode;
    }
}
exports.DBOSError = DBOSError;
const WorkflowPermissionDeniedError = 2;
class DBOSWorkflowPermissionDeniedError extends DBOSError {
    constructor(runAs, workflowName) {
        const msg = `Subject ${runAs} does not have permission to run workflow ${workflowName}`;
        super(msg, WorkflowPermissionDeniedError);
    }
}
exports.DBOSWorkflowPermissionDeniedError = DBOSWorkflowPermissionDeniedError;
const InitializationError = 3;
class DBOSInitializationError extends DBOSError {
    constructor(msg) {
        super(msg, InitializationError);
    }
}
exports.DBOSInitializationError = DBOSInitializationError;
const TopicPermissionDeniedError = 4;
class DBOSTopicPermissionDeniedError extends DBOSError {
    constructor(destinationUUID, workflowUUID, functionID, runAs) {
        const msg = `Subject ${runAs} does not have permission on destination UUID ${destinationUUID}.` + `(workflow UUID: ${workflowUUID}, function ID: ${functionID})`;
        super(msg, TopicPermissionDeniedError);
    }
}
exports.DBOSTopicPermissionDeniedError = DBOSTopicPermissionDeniedError;
const ConflictingUUIDError = 5;
class DBOSWorkflowConflictUUIDError extends DBOSError {
    constructor(workflowUUID) {
        super(`Conflicting UUID ${workflowUUID}`, ConflictingUUIDError);
    }
}
exports.DBOSWorkflowConflictUUIDError = DBOSWorkflowConflictUUIDError;
const NotRegisteredError = 6;
class DBOSNotRegisteredError extends DBOSError {
    constructor(name) {
        const msg = `Operation (Name: ${name}) not registered`;
        super(msg, NotRegisteredError);
    }
}
exports.DBOSNotRegisteredError = DBOSNotRegisteredError;
const PostgresExporterError = 7;
class DBOSPostgresExporterError extends DBOSError {
    constructor(err) {
        let msg = `PostgresExporter error: ${err.message} \n`;
        if (err instanceof pg_1.DatabaseError) {
            msg = msg.concat(formatPgDatabaseError(err));
        }
        super(msg, PostgresExporterError);
    }
}
exports.DBOSPostgresExporterError = DBOSPostgresExporterError;
const DataValidationError = 9;
class DBOSDataValidationError extends DBOSError {
    constructor(msg) {
        super(msg, DataValidationError);
    }
}
exports.DBOSDataValidationError = DBOSDataValidationError;
// This error is thrown by applications.
const ResponseError = 11;
class DBOSResponseError extends DBOSError {
    status;
    constructor(msg, status = 500) {
        super(msg, ResponseError);
        this.status = status;
    }
}
exports.DBOSResponseError = DBOSResponseError;
const NotAuthorizedError = 12;
class DBOSNotAuthorizedError extends DBOSError {
    status;
    constructor(msg, status = 403) {
        super(msg, NotAuthorizedError);
        this.status = status;
    }
}
exports.DBOSNotAuthorizedError = DBOSNotAuthorizedError;
const UndefinedDecoratorInputError = 13;
class DBOSUndefinedDecoratorInputError extends DBOSError {
    constructor(decoratorName) {
        super(`${decoratorName} received undefined input. Possible circular dependency?`, UndefinedDecoratorInputError);
    }
}
exports.DBOSUndefinedDecoratorInputError = DBOSUndefinedDecoratorInputError;
const ConfigKeyTypeError = 14;
class DBOSConfigKeyTypeError extends DBOSError {
    constructor(configKey, expectedType, actualType) {
        super(`${configKey} should be of type ${expectedType}, but got ${actualType}`, ConfigKeyTypeError);
    }
}
exports.DBOSConfigKeyTypeError = DBOSConfigKeyTypeError;
const DebuggerError = 15;
class DBOSDebuggerError extends DBOSError {
    constructor(msg) {
        super("DEBUGGER: " + msg, DebuggerError);
    }
}
exports.DBOSDebuggerError = DBOSDebuggerError;
const NonExistentWorkflowError = 16;
class DBOSNonExistentWorkflowError extends DBOSError {
    constructor(msg) {
        super(msg, NonExistentWorkflowError);
    }
}
exports.DBOSNonExistentWorkflowError = DBOSNonExistentWorkflowError;
const FailLoadOperationsError = 17;
class DBOSFailLoadOperationsError extends DBOSError {
    constructor(msg) {
        super(msg, FailLoadOperationsError);
    }
}
exports.DBOSFailLoadOperationsError = DBOSFailLoadOperationsError;
const DeadLetterQueueError = 18;
class DBOSDeadLetterQueueError extends DBOSError {
    constructor(workflowUUID, maxRetries) {
        super(`Workflow ${workflowUUID} has been moved to the dead-letter queue after exceeding the maximum of ${maxRetries} retries`, DeadLetterQueueError);
    }
}
exports.DBOSDeadLetterQueueError = DBOSDeadLetterQueueError;
const FailedSqlTransactionError = 19;
class DBOSFailedSqlTransactionError extends DBOSError {
    constructor(workflowUUID, txnName) {
        super(`Postgres aborted the ${txnName} transaction of Workflow ${workflowUUID}.`, FailedSqlTransactionError);
    }
}
exports.DBOSFailedSqlTransactionError = DBOSFailedSqlTransactionError;
const ExecutorNotInitializedError = 20;
class DBOSExecutorNotInitializedError extends DBOSError {
    constructor() {
        super("DBOS not initialized", ExecutorNotInitializedError);
    }
}
exports.DBOSExecutorNotInitializedError = DBOSExecutorNotInitializedError;
const InvalidWorkflowTransition = 21;
class DBOSInvalidWorkflowTransitionError extends DBOSError {
    constructor() {
        super("Invalid workflow state", InvalidWorkflowTransition);
    }
}
exports.DBOSInvalidWorkflowTransitionError = DBOSInvalidWorkflowTransitionError;
//# sourceMappingURL=error.js.map