"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.exhaustiveCheckGuard = exports.DBOSJSON = exports.DBOSReviver = exports.DBOSReplacer = exports.findPackageRoot = exports.sleepms = exports.readFileSync = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
/*
 * Use the node.js `fs` module to read the content of a file
 * Handles cases where:
 * - the file does not exist
 * - the file is not a valid file
 **/
function readFileSync(path, encoding = "utf8") {
    // First, check the file
    fs_1.default.stat(path, (error, stats) => {
        if (error) {
            throw new Error(`checking on ${path}. ${error.code}: ${error.errno}`);
        }
        else if (!stats.isFile()) {
            throw new Error(`config file ${path} is not a file`);
        }
    });
    // Then, read its content
    return fs_1.default.readFileSync(path, { encoding });
}
exports.readFileSync = readFileSync;
const sleepms = (ms) => new Promise((r) => setTimeout(r, ms));
exports.sleepms = sleepms;
// Adapated and translated from from: https://github.com/junosuarez/find-root
function findPackageRoot(start) {
    if (typeof start === 'string') {
        if (!start.endsWith(path_1.default.sep)) {
            start += path_1.default.sep;
        }
        start = start.split(path_1.default.sep);
    }
    if (start.length === 0) {
        throw new Error('package.json not found in path');
    }
    start.pop();
    const dir = start.join(path_1.default.sep);
    if (fs_1.default.existsSync(path_1.default.join(dir, 'package.json'))) {
        return dir;
    }
    return findPackageRoot(start);
}
exports.findPackageRoot = findPackageRoot;
//https://www.typescriptlang.org/docs/handbook/2/functions.html#declaring-this-in-a-function
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function DBOSReplacer(key, value) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment
    const actualValue = this[key];
    if (actualValue instanceof Date) {
        const res = {
            dbos_type: 'dbos_Date',
            dbos_data: actualValue.toISOString()
        };
        return res;
    }
    if (typeof actualValue === 'bigint') {
        const res = {
            dbos_type: 'dbos_BigInt',
            dbos_data: actualValue.toString(),
        };
        return res;
    }
    return value;
}
exports.DBOSReplacer = DBOSReplacer;
function isSerializedBuffer(value) {
    return typeof value === 'object'
        && value !== null
        && value.type === 'Buffer';
}
function isSerializedDate(value) {
    return typeof value === 'object'
        && value !== null
        && value.dbos_type === 'dbos_Date';
}
function isSerializedBigInt(value) {
    return typeof value === 'object'
        && value !== null
        && value.dbos_type === 'dbos_BigInt';
}
function DBOSReviver(_key, value) {
    switch (true) {
        case isSerializedBuffer(value):
            return Buffer.from(value.data);
        case isSerializedDate(value):
            return new Date(Date.parse(value.dbos_data));
        case isSerializedBigInt(value):
            return BigInt(value.dbos_data);
        default:
            return value;
    }
}
exports.DBOSReviver = DBOSReviver;
exports.DBOSJSON = {
    parse: (text) => {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return JSON.parse(text, DBOSReviver);
    },
    stringify: (value) => {
        return JSON.stringify(value, DBOSReplacer);
    }
};
function exhaustiveCheckGuard(_) {
    throw new Error('Exaustive matching is not applied');
}
exports.exhaustiveCheckGuard = exhaustiveCheckGuard;
//# sourceMappingURL=utils.js.map