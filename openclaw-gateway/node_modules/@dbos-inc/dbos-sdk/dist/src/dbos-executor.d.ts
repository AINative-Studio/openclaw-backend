/// <reference types="node" />
import { Workflow, WorkflowConfig, WorkflowHandle, WorkflowParams, WorkflowContextImpl, WorkflowStatus, BufferedResult, GetWorkflowQueueInput, GetWorkflowQueueOutput } from './workflow';
import { Transaction, TransactionConfig } from './transaction';
import { StepConfig, StepFunction } from './step';
import { TelemetryCollector } from './telemetry/collector';
import { Tracer } from './telemetry/traces';
import { GlobalLogger as Logger } from './telemetry/logs';
import { TelemetryConfig } from './telemetry';
import { Pool, PoolClient, PoolConfig, QueryResultRow } from 'pg';
import { SystemDatabase } from './system_database';
import { UserDatabase, UserDatabaseName } from './user_database';
import { MethodRegistrationBase, ConfiguredInstance } from './decorators';
import { StoredProcedure, StoredProcedureConfig } from './procedure';
import { DBOSEventReceiver, DBOSExecutorContext, GetWorkflowsInput, GetWorkflowsOutput } from ".";
import { DBOSScheduler } from './scheduler/scheduler';
import { DBOSEventReceiverState, DBOSEventReceiverQuery, DBNotificationCallback, DBNotificationListener } from "./eventreceiver";
export interface DBOSNull {
}
export declare const dbosNull: DBOSNull;
export interface DBOSConfig {
    readonly poolConfig: PoolConfig;
    readonly userDbclient?: UserDatabaseName;
    readonly telemetry?: TelemetryConfig;
    readonly system_database: string;
    readonly env?: Record<string, string>;
    readonly application?: object;
    readonly debugProxy?: string;
    readonly debugMode?: boolean;
    readonly appVersion?: string;
    readonly http?: {
        readonly cors_middleware?: boolean;
        readonly credentials?: boolean;
        readonly allowed_origins?: string[];
    };
}
interface WorkflowRegInfo {
    workflow: Workflow<unknown[], unknown>;
    config: WorkflowConfig;
    registration?: MethodRegistrationBase;
}
interface TransactionRegInfo {
    transaction: Transaction<unknown[], unknown>;
    config: TransactionConfig;
    registration: MethodRegistrationBase;
}
interface StepRegInfo {
    step: StepFunction<unknown[], unknown>;
    config: StepConfig;
    registration: MethodRegistrationBase;
}
interface ProcedureRegInfo {
    procedure: StoredProcedure<unknown>;
    config: StoredProcedureConfig;
    registration: MethodRegistrationBase;
}
export interface InternalWorkflowParams extends WorkflowParams {
    readonly tempWfType?: string;
    readonly tempWfName?: string;
    readonly tempWfClass?: string;
}
export declare const OperationType: {
    readonly HANDLER: "handler";
    readonly WORKFLOW: "workflow";
    readonly TRANSACTION: "transaction";
    readonly COMMUNICATOR: "communicator";
    readonly PROCEDURE: "procedure";
};
export declare class DBOSExecutor implements DBOSExecutorContext {
    #private;
    readonly config: DBOSConfig;
    initialized: boolean;
    userDatabase: UserDatabase;
    readonly systemDatabase: SystemDatabase;
    readonly procedurePool: Pool;
    static readonly tempWorkflowName = "temp_workflow";
    readonly workflowInfoMap: Map<string, WorkflowRegInfo>;
    readonly transactionInfoMap: Map<string, TransactionRegInfo>;
    readonly stepInfoMap: Map<string, StepRegInfo>;
    readonly procedureInfoMap: Map<string, ProcedureRegInfo>;
    readonly registeredOperations: Array<MethodRegistrationBase>;
    readonly pendingWorkflowMap: Map<string, Promise<unknown>>;
    readonly workflowResultBuffer: Map<string, Map<number, BufferedResult>>;
    readonly telemetryCollector: TelemetryCollector;
    readonly flushBufferIntervalMs: number;
    readonly flushBufferID: NodeJS.Timeout;
    isFlushingBuffers: boolean;
    static readonly defaultNotificationTimeoutSec = 60;
    readonly debugMode: boolean;
    readonly debugProxy: string | undefined;
    static systemDBSchemaName: string;
    readonly logger: Logger;
    readonly tracer: Tracer;
    typeormEntities: Function[];
    drizzleEntities: {
        [key: string]: object;
    };
    eventReceivers: DBOSEventReceiver[];
    scheduler?: DBOSScheduler;
    wfqEnded?: Promise<void>;
    static globalInstance: DBOSExecutor | undefined;
    constructor(config: DBOSConfig, systemDatabase?: SystemDatabase);
    configureDbClient(): void;
    getRegistrationsFor(obj: DBOSEventReceiver): {
        methodConfig: unknown;
        classConfig: unknown;
        methodReg: MethodRegistrationBase;
    }[];
    init(classes?: object[]): Promise<void>;
    callProcedure<R extends QueryResultRow = any>(proc: StoredProcedure<unknown>, args: unknown[]): Promise<R[]>;
    destroy(): Promise<void>;
    getWorkflowInfo(wf: Workflow<unknown[], unknown>): WorkflowRegInfo | undefined;
    getWorkflowInfoByStatus(wf: WorkflowStatus): {
        wfInfo: WorkflowRegInfo | undefined;
        configuredInst: ConfiguredInstance | null;
    };
    getTransactionInfo(tf: Transaction<unknown[], unknown>): TransactionRegInfo | undefined;
    getTransactionInfoByNames(className: string, functionName: string, cfgName: string): {
        txnInfo: TransactionRegInfo | undefined;
        clsInst: ConfiguredInstance | null;
    };
    getStepInfo(cf: StepFunction<unknown[], unknown>): StepRegInfo | undefined;
    getStepInfoByNames(className: string, functionName: string, cfgName: string): {
        commInfo: StepRegInfo | undefined;
        clsInst: ConfiguredInstance | null;
    };
    getProcedureClassName(pf: StoredProcedure<unknown>): string;
    getProcedureInfo(pf: StoredProcedure<unknown>): ProcedureRegInfo | undefined;
    workflow<T extends unknown[], R>(wf: Workflow<T, R>, params: InternalWorkflowParams, ...args: T): Promise<WorkflowHandle<R>>;
    internalWorkflow<T extends unknown[], R>(wf: Workflow<T, R>, params: InternalWorkflowParams, callerUUID?: string, callerFunctionID?: number, ...args: T): Promise<WorkflowHandle<R>>;
    /**
     * DEBUG MODE workflow execution, skipping all the recording
     */
    debugWorkflow<T extends unknown[], R>(wf: Workflow<T, R>, params: WorkflowParams, callerUUID?: string, callerFunctionID?: number, ...args: T): Promise<WorkflowHandle<R>>;
    transaction<T extends unknown[], R>(txn: Transaction<T, R>, params: WorkflowParams, ...args: T): Promise<R>;
    callTransactionFunction<T extends unknown[], R>(txn: Transaction<T, R>, clsinst: ConfiguredInstance | null, wfCtx: WorkflowContextImpl, ...args: T): Promise<R>;
    procedure<R>(proc: StoredProcedure<R>, params: WorkflowParams, ...args: unknown[]): Promise<R>;
    executeProcedure<R>(func: (client: PoolClient) => Promise<R>, config: TransactionConfig): Promise<R>;
    external<T extends unknown[], R>(stepFn: StepFunction<T, R>, params: WorkflowParams, ...args: T): Promise<R>;
    /**
     * Execute a step function.
     * If it encounters any error, retry according to its configured retry policy until the maximum number of attempts is reached, then throw an DBOSError.
     * The step may execute many times, but once it is complete, it will not re-execute.
     */
    callStepFunction<T extends unknown[], R>(stepFn: StepFunction<T, R>, clsInst: ConfiguredInstance | null, wfCtx: WorkflowContextImpl, ...args: T): Promise<R>;
    send<T>(destinationUUID: string, message: T, topic?: string, idempotencyKey?: string): Promise<void>;
    /**
     * Wait for a workflow to emit an event, then return its value.
     */
    getEvent<T>(workflowUUID: string, key: string, timeoutSeconds?: number): Promise<T | null>;
    /**
     * Retrieve a handle for a workflow UUID.
     */
    retrieveWorkflow<R>(workflowID: string): WorkflowHandle<R>;
    getWorkflowStatus(workflowID: string): Promise<WorkflowStatus | null>;
    getWorkflows(input: GetWorkflowsInput): Promise<GetWorkflowsOutput>;
    getWorkflowQueue(input: GetWorkflowQueueInput): Promise<GetWorkflowQueueOutput>;
    queryUserDB(sql: string, params?: unknown[]): Promise<unknown[]>;
    userDBListen(channels: string[], callback: DBNotificationCallback): Promise<DBNotificationListener>;
    /**
     * A recovery process that by default runs during executor init time.
     * It runs to completion all pending workflows that were executing when the previous executor failed.
     */
    recoverPendingWorkflows(executorIDs?: string[]): Promise<WorkflowHandle<unknown>[]>;
    deactivateEventReceivers(): Promise<void>;
    executeWorkflowUUID(workflowUUID: string, startNewWorkflow?: boolean): Promise<WorkflowHandle<unknown>>;
    getEventDispatchState(svc: string, wfn: string, key: string): Promise<DBOSEventReceiverState | undefined>;
    queryEventDispatchState(query: DBOSEventReceiverQuery): Promise<DBOSEventReceiverState[]>;
    upsertEventDispatchState(state: DBOSEventReceiverState): Promise<DBOSEventReceiverState>;
    /**
     * Periodically flush the workflow output buffer to the system database.
     */
    flushWorkflowBuffers(): Promise<void>;
    flushWorkflowResultBuffer(): Promise<void>;
    logRegisteredHTTPUrls(): void;
    getConfig<T>(key: string, defaultValue?: T): T | undefined;
}
export {};
//# sourceMappingURL=dbos-executor.d.ts.map