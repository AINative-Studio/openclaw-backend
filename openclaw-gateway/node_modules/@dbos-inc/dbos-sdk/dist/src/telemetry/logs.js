"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = exports.GlobalLogger = void 0;
const winston_1 = require("winston");
const TransportStream = require("winston-transport"); // eslint-disable-line @typescript-eslint/no-require-imports
const api_logs_1 = require("@opentelemetry/api-logs");
const sdk_logs_1 = require("@opentelemetry/sdk-logs");
const utils_1 = require("../utils");
class GlobalLogger {
    telemetryCollector;
    logger;
    addContextMetadata;
    constructor(telemetryCollector, config) {
        this.telemetryCollector = telemetryCollector;
        const winstonTransports = [];
        winstonTransports.push(new winston_1.transports.Console({
            format: consoleFormat,
            level: config?.logLevel || "info",
            silent: config?.silent || false,
        }));
        // Only enable the OTLP transport if we have a telemetry collector and an exporter
        if (this.telemetryCollector?.exporter) {
            winstonTransports.push(new OTLPLogQueueTransport(this.telemetryCollector, config?.logLevel || "info"));
        }
        this.logger = (0, winston_1.createLogger)({ transports: winstonTransports });
        this.addContextMetadata = config?.addContextMetadata || false;
    }
    // We use this form of winston logging methods: `(message: string, ...meta: any[])`. See node_modules/winston/index.d.ts
    info(logEntry, metadata) {
        if (typeof logEntry === "string") {
            this.logger.info(logEntry, metadata);
        }
        else {
            this.logger.info(utils_1.DBOSJSON.stringify(logEntry), metadata);
        }
    }
    debug(logEntry, metadata) {
        if (typeof logEntry === "string") {
            this.logger.debug(logEntry, metadata);
        }
        else {
            this.logger.debug(utils_1.DBOSJSON.stringify(logEntry), metadata);
        }
    }
    warn(logEntry, metadata) {
        if (typeof logEntry === "string") {
            this.logger.warn(logEntry, metadata);
        }
        else {
            this.logger.warn(utils_1.DBOSJSON.stringify(logEntry), metadata);
        }
    }
    // metadata can have both ContextualMetadata and the error stack trace
    error(inputError, metadata) {
        if (inputError instanceof Error) {
            this.logger.error(inputError.message, { ...metadata, stack: inputError.stack });
        }
        else if (typeof inputError === "string") {
            this.logger.error(inputError, { ...metadata, stack: new Error().stack });
        }
        else {
            this.logger.error(utils_1.DBOSJSON.stringify(inputError), { ...metadata, stack: new Error().stack });
        }
    }
    async destroy() {
        await this.telemetryCollector?.destroy();
    }
}
exports.GlobalLogger = GlobalLogger;
// Wrapper around our global logger. Expected to be instantiated by a new contexts so they can inject contextual metadata
class Logger {
    globalLogger;
    ctx;
    metadata;
    constructor(globalLogger, ctx) {
        this.globalLogger = globalLogger;
        this.ctx = ctx;
        this.metadata = {
            span: ctx.span,
            includeContextMetadata: this.globalLogger.addContextMetadata,
        };
    }
    info(logEntry, metadata) {
        this.globalLogger.info(logEntry, metadata ?? this.metadata);
    }
    debug(logEntry, metadata) {
        this.globalLogger.debug(logEntry, metadata ?? this.metadata);
    }
    warn(logEntry, metadata) {
        this.globalLogger.warn(logEntry, metadata ?? this.metadata);
    }
    error(inputError, metadata) {
        this.globalLogger.error(inputError, metadata ?? this.metadata);
    }
}
exports.Logger = Logger;
/***********************/
/* FORMAT & TRANSPORTS */
/***********************/
const consoleFormat = winston_1.format.combine(winston_1.format.errors({ stack: true }), winston_1.format.timestamp(), winston_1.format.colorize(), winston_1.format.printf((info) => {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const { timestamp, level, message, stack } = info;
    const applicationVersion = process.env.DBOS__APPVERSION || "";
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-assignment
    const ts = timestamp.slice(0, 19).replace("T", " ");
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-assignment
    const formattedStack = stack?.split("\n").slice(1).join("\n");
    const messageString = typeof message === "string" ? message : utils_1.DBOSJSON.stringify(message);
    const fullMessageString = `${messageString}${info.includeContextMetadata ? ` ${utils_1.DBOSJSON.stringify(info.span?.attributes)}` : ""}`;
    const versionString = applicationVersion ? ` [version ${applicationVersion}]` : "";
    return `${ts}${versionString} [${level}]: ${fullMessageString} ${stack ? "\n" + formattedStack : ""}`;
}));
class OTLPLogQueueTransport extends TransportStream {
    telemetryCollector;
    name = "OTLPLogQueueTransport";
    otelLogger;
    applicationID;
    applicationVersion;
    executorID;
    constructor(telemetryCollector, logLevel) {
        super();
        this.telemetryCollector = telemetryCollector;
        this.level = logLevel;
        // not sure if we need a more explicit name here
        const loggerProvider = new sdk_logs_1.LoggerProvider();
        this.otelLogger = loggerProvider.getLogger("default");
        this.applicationID = process.env.DBOS__APPID || "";
        this.applicationVersion = process.env.DBOS__APPVERSION || "";
        this.executorID = process.env.DBOS__VMID || "local";
        const logRecordProcessor = {
            forceFlush: async () => {
                // no-op
            },
            onEmit(logRecord) {
                telemetryCollector.push(logRecord);
            },
            shutdown: async () => {
                // no-op
            },
        };
        loggerProvider.addLogRecordProcessor(logRecordProcessor);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    log(info, callback) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const { level, message, stack, span } = info;
        const levelToSeverityNumber = {
            error: api_logs_1.SeverityNumber.ERROR,
            warn: api_logs_1.SeverityNumber.WARN,
            info: api_logs_1.SeverityNumber.INFO,
            debug: api_logs_1.SeverityNumber.DEBUG,
        };
        // Ideally we want to give the spanContext to the logRecord,
        // But there seems to some dependency bugs in opentelemetry-js
        // (span.getValue(SPAN_KEY) undefined when we pass the context, as commented bellow)
        // So for now we get the traceId and spanId directly from the context and pass them through the logRecord attributes
        this.otelLogger.emit({
            severityNumber: levelToSeverityNumber[level],
            severityText: level,
            body: message,
            timestamp: performance.now(), // So far I don't see a major difference between this and observedTimestamp
            observedTimestamp: performance.now(),
            attributes: {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                ...span?.attributes,
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
                traceId: span?.spanContext()?.traceId,
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
                spanId: span?.spanContext()?.spanId,
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                stack,
                applicationID: this.applicationID,
                applicationVersion: this.applicationVersion,
                executorID: this.executorID,
            },
        });
        callback();
    }
}
//# sourceMappingURL=logs.js.map