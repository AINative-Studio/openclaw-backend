"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TelemetryExporter = void 0;
const _1 = require("./");
const exporter_trace_otlp_proto_1 = require("@opentelemetry/exporter-trace-otlp-proto");
const exporter_logs_otlp_proto_1 = require("@opentelemetry/exporter-logs-otlp-proto");
const core_1 = require("@opentelemetry/core");
class TelemetryExporter {
    tracesExporter;
    logsExporter;
    constructor(config) {
        if (config.tracesEndpoint) {
            this.tracesExporter = new exporter_trace_otlp_proto_1.OTLPTraceExporter({
                url: config.tracesEndpoint,
            });
            console.log(`Traces will be exported to ${config.tracesEndpoint}`);
        }
        if (config.logsEndpoint) {
            this.logsExporter = new exporter_logs_otlp_proto_1.OTLPLogExporter({
                url: config.logsEndpoint,
            });
            console.log(`Logs will be exported to ${config.logsEndpoint}`);
        }
    }
    async export(signals) {
        // Sort out traces and logs
        const exportSpans = [];
        const exportLogs = [];
        signals.forEach((signal) => {
            if ((0, _1.isTraceSignal)(signal)) {
                exportSpans.push(signal);
            }
            if ((0, _1.isLogSignal)(signal)) {
                exportLogs.push(signal);
            }
        });
        const tasks = [];
        // A short-lived app that exits before the callback of export() will lose its data.
        // We wrap these callbacks in promise objects to make sure we wait for them:
        if (exportSpans.length > 0 && this.tracesExporter) {
            const traceExportTask = new Promise((resolve) => {
                const exportCallback = (results) => {
                    if (results.code !== core_1.ExportResultCode.SUCCESS) {
                        console.warn(`Trace export failed: ${results.code}`);
                        console.warn(results);
                    }
                    resolve();
                };
                this.tracesExporter?.export(exportSpans, exportCallback);
            });
            tasks.push(traceExportTask);
        }
        if (exportLogs.length > 0 && this.logsExporter) {
            const logExportTask = new Promise((resolve) => {
                const exportCallback = (results) => {
                    if (results.code !== core_1.ExportResultCode.SUCCESS) {
                        console.warn(`Log export failed: ${results.code}`);
                        console.warn(results);
                    }
                    resolve();
                };
                this.logsExporter?.export(exportLogs, exportCallback);
            });
            tasks.push(logExportTask);
        }
        await Promise.all(tasks);
    }
    async flush() {
        await this.logsExporter?.forceFlush();
        await this.tracesExporter?.forceFlush();
    }
}
exports.TelemetryExporter = TelemetryExporter;
//# sourceMappingURL=exporters.js.map