"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DBOSScheduler = exports.Scheduled = exports.SchedulerConfig = exports.SchedulerMode = void 0;
const decorators_1 = require("../decorators");
const crontab_1 = require("./crontab");
////
// Configuration
////
var SchedulerMode;
(function (SchedulerMode) {
    SchedulerMode["ExactlyOncePerInterval"] = "ExactlyOncePerInterval";
    SchedulerMode["ExactlyOncePerIntervalWhenActive"] = "ExactlyOncePerIntervalWhenActive";
})(SchedulerMode || (exports.SchedulerMode = SchedulerMode = {}));
class SchedulerConfig {
    crontab = '* * * * *'; // Every minute
    mode = SchedulerMode.ExactlyOncePerIntervalWhenActive;
    queueName;
}
exports.SchedulerConfig = SchedulerConfig;
function Scheduled(schedulerConfig) {
    function scheddec(target, propertyKey, inDescriptor) {
        const { descriptor, registration } = (0, decorators_1.registerAndWrapFunction)(target, propertyKey, inDescriptor);
        const schedRegistration = registration;
        schedRegistration.schedulerConfig = schedulerConfig;
        return descriptor;
    }
    return scheddec;
}
exports.Scheduled = Scheduled;
///////////////////////////
// Scheduler Management
///////////////////////////
class DBOSScheduler {
    dbosExec;
    constructor(dbosExec) {
        this.dbosExec = dbosExec;
        dbosExec.scheduler = this;
    }
    schedLoops = [];
    schedTasks = [];
    initScheduler() {
        for (const registeredOperation of this.dbosExec.registeredOperations) {
            const ro = registeredOperation;
            if (ro.schedulerConfig) {
                const loop = new DetachableLoop(this.dbosExec, ro.schedulerConfig.crontab ?? '* * * * *', ro.schedulerConfig.mode ?? SchedulerMode.ExactlyOncePerInterval, ro, ro.schedulerConfig?.queueName);
                this.schedLoops.push(loop);
                this.schedTasks.push(loop.startLoop());
            }
        }
    }
    async destroyScheduler() {
        for (const l of this.schedLoops) {
            l.setStopLoopFlag();
        }
        this.schedLoops = [];
        try {
            await Promise.allSettled(this.schedTasks);
        }
        catch (e) {
            //  What gets caught here is the loop stopping, which is what we wanted.
        }
        this.schedTasks = [];
    }
    logRegisteredSchedulerEndpoints() {
        const logger = this.dbosExec.logger;
        logger.info("Scheduled endpoints:");
        this.dbosExec.registeredOperations.forEach((registeredOperation) => {
            const ro = registeredOperation;
            if (ro.schedulerConfig) {
                logger.info(`    ${ro.name} @ ${ro.schedulerConfig.crontab}; ${ro.schedulerConfig.mode ?? SchedulerMode.ExactlyOncePerInterval}`);
            }
        });
    }
}
exports.DBOSScheduler = DBOSScheduler;
const SCHEDULER_EVENT_SERVICE_NAME = 'dbos.scheduler';
class DetachableLoop {
    dbosExec;
    crontab;
    schedMode;
    scheduledMethod;
    queueName;
    isRunning = false;
    interruptResolve;
    lastExec;
    timeMatcher;
    scheduledMethodName;
    constructor(dbosExec, crontab, schedMode, scheduledMethod, queueName) {
        this.dbosExec = dbosExec;
        this.crontab = crontab;
        this.schedMode = schedMode;
        this.scheduledMethod = scheduledMethod;
        this.queueName = queueName;
        this.lastExec = new Date();
        this.lastExec.setMilliseconds(0);
        this.timeMatcher = new crontab_1.TimeMatcher(crontab);
        this.scheduledMethodName = `${scheduledMethod.className}.${scheduledMethod.name}`;
    }
    async startLoop() {
        // See if the exec time is available in durable storage...
        if (this.schedMode === SchedulerMode.ExactlyOncePerInterval) {
            const lastState = await this.dbosExec.systemDatabase.getEventDispatchState(SCHEDULER_EVENT_SERVICE_NAME, this.scheduledMethodName, 'lastState');
            const lasttm = lastState?.value;
            if (lasttm) {
                this.lastExec = new Date(parseFloat(lasttm));
            }
        }
        this.isRunning = true;
        while (this.isRunning) {
            const nextExecTime = this.timeMatcher.nextWakeupTime(this.lastExec);
            const sleepTime = nextExecTime.getTime() - new Date().getTime();
            if (sleepTime > 0) {
                // Wait for either the timeout or an interruption
                let timer;
                const timeoutPromise = new Promise((resolve) => {
                    timer = setTimeout(() => {
                        resolve();
                    }, sleepTime);
                });
                await Promise.race([
                    timeoutPromise,
                    new Promise((_, reject) => this.interruptResolve = reject)
                ])
                    .catch(() => { this.dbosExec.logger.debug("Scheduler loop interrupted!"); }); // Interrupt sleep throws
                clearTimeout(timer);
            }
            if (!this.isRunning) {
                break;
            }
            // Check crontab
            // If this "wake up" time is not on the schedule, we shouldn't execute.
            //  (While ATOW this wake-up time is a scheduled run time, it is not
            //   contractually obligated to be so.  If this is obligated to be a
            //   scheduled execution time, then we could make this an assertion
            //   instead of a check.)
            if (!this.timeMatcher.match(nextExecTime)) {
                this.lastExec = nextExecTime;
                continue;
            }
            // Init workflow
            const workflowUUID = `sched-${this.scheduledMethodName}-${nextExecTime.toISOString()}`;
            this.dbosExec.logger.debug(`Executing scheduled workflow ${workflowUUID}`);
            const wfParams = {
                workflowUUID: workflowUUID, configuredInstance: null, queueName: this.queueName,
            };
            // All operations annotated with Scheduled decorators must take in these four
            const args = [nextExecTime, new Date()];
            // We currently only support scheduled workflows
            if (this.scheduledMethod.workflowConfig) {
                // Execute the workflow
                await this.dbosExec.workflow(this.scheduledMethod.registeredFunction, wfParams, ...args);
            }
            else {
                this.dbosExec.logger.error(`Function ${this.scheduledMethodName} is @scheduled but not a workflow`);
            }
            // Record the time of the wf kicked off
            const ers = {
                service: SCHEDULER_EVENT_SERVICE_NAME,
                workflowFnName: this.scheduledMethodName,
                key: 'lastState',
                value: `${nextExecTime.getTime()}`,
                updateTime: nextExecTime.getTime(),
            };
            const updRec = await this.dbosExec.systemDatabase.upsertEventDispatchState(ers);
            const dbTime = parseFloat(updRec.value);
            if (dbTime && dbTime > nextExecTime.getTime())
                nextExecTime.setTime(dbTime);
            this.lastExec = nextExecTime;
        }
    }
    setStopLoopFlag() {
        if (!this.isRunning)
            return;
        this.isRunning = false;
        if (this.interruptResolve) {
            this.interruptResolve(); // Trigger the interruption
        }
    }
}
//# sourceMappingURL=scheduler.js.map