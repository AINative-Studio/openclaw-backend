/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node/http" />
import { Span } from "@opentelemetry/sdk-trace-base";
import { HTTPRequest } from "./context";
import { DBOSConfig } from "./dbos-executor";
import { GetWorkflowQueueInput, GetWorkflowQueueOutput, GetWorkflowsInput, GetWorkflowsOutput, WorkflowConfig } from "./workflow";
import { DBOSExecutorContext } from "./eventreceiver";
import { DLogger } from "./telemetry/logs";
import { DBOSRuntimeConfig } from "./dbos-runtime/runtime";
import { ScheduledArgs, SchedulerConfig } from "./scheduler/scheduler";
import { MethodRegistration } from "./decorators";
import { Server } from "http";
import { DrizzleClient, PrismaClient, TypeORMEntityManager, UserDatabaseClient } from "./user_database";
import { TransactionConfig } from "./transaction";
import Koa from "koa";
import { Application as ExpressApp } from "express";
import { INestApplication } from "@nestjs/common";
import { FastifyInstance } from "fastify";
import { PoolClient } from "pg";
import { Knex } from "knex";
import { StepConfig } from "./step";
import { StepContext, StoredProcedureContext, TransactionContext, WorkflowHandle } from ".";
import { ConfiguredInstance } from ".";
export interface DBOSHttpApps {
    koaApp?: Koa;
    expressApp?: ExpressApp;
    nestApp?: INestApplication;
    fastifyApp?: FastifyInstance;
}
type PossiblyWFFunc = (...args: any[]) => Promise<unknown>;
type InvokeFunctionsAsync<T> = T extends Function ? {
    [P in keyof T]: T[P] extends PossiblyWFFunc ? (...args: Parameters<T[P]>) => Promise<WorkflowHandle<Awaited<ReturnType<T[P]>>>> : never;
} : never;
type InvokeFunctionsAsyncInst<T> = T extends ConfiguredInstance ? {
    [P in keyof T]: T[P] extends PossiblyWFFunc ? (...args: Parameters<T[P]>) => Promise<WorkflowHandle<Awaited<ReturnType<T[P]>>>> : never;
} : never;
export type TailParameters<T extends (arg: any, args: any[]) => any> = T extends (arg: any, ...args: infer P) => any ? P : never;
type TxFunc = (ctxt: TransactionContext<any>, ...args: any[]) => Promise<any>;
type StepFunc = (ctxt: StepContext, ...args: any[]) => Promise<any>;
type ProcFunc = (ctxt: StoredProcedureContext, ...args: any[]) => Promise<any>;
type InvokeFuncs<T> = T extends ConfiguredInstance ? never : {
    [P in keyof T as T[P] extends TxFunc | StepFunc | ProcFunc ? P : never]: T[P] extends TxFunc | StepFunc | ProcFunc ? (...args: TailParameters<T[P]>) => ReturnType<T[P]> : never;
};
type InvokeFuncsInst<T> = T extends ConfiguredInstance ? {
    [P in keyof T as T[P] extends TxFunc | StepFunc ? P : never]: T[P] extends TxFunc | StepFunc ? (...args: TailParameters<T[P]>) => ReturnType<T[P]> : never;
} : never;
export interface StartWorkflowParams {
    workflowID?: string;
    queueName?: string;
}
export declare class DBOS {
    static adminServer: Server | undefined;
    static appServer: Server | undefined;
    static setConfig(config: DBOSConfig, runtimeConfig?: DBOSRuntimeConfig): void;
    static setAppConfig<T>(key: string, newValue: T): void;
    static launch(httpApps?: DBOSHttpApps): Promise<void>;
    static shutdown(): Promise<void>;
    static get executor(): DBOSExecutorContext;
    static launchAppHTTPServer(): Promise<void>;
    static getHTTPHandlersCallback(): ((req: import("http").IncomingMessage | import("http2").Http2ServerRequest, res: import("http2").Http2ServerResponse | import("http").ServerResponse<import("http").IncomingMessage>) => Promise<void>) | undefined;
    static globalLogger?: DLogger;
    static dbosConfig?: DBOSConfig;
    static runtimeConfig?: DBOSRuntimeConfig;
    static invokeWrappers: Map<unknown, unknown>;
    static get logger(): DLogger;
    static get span(): Span | undefined;
    static getRequest(): HTTPRequest | undefined;
    static get request(): HTTPRequest;
    static getKoaContext(): Koa.Context | undefined;
    static get koaContext(): Koa.Context;
    static get workflowID(): string | undefined;
    static get authenticatedUser(): string;
    static get authenticatedRoles(): string[];
    static get assumedRole(): string;
    static isInTransaction(): boolean;
    static isInStep(): boolean;
    static isWithinWorkflow(): boolean;
    static isInWorkflow(): boolean;
    static get sqlClient(): UserDatabaseClient;
    static get pgClient(): PoolClient;
    static get knexClient(): Knex;
    static get prismaClient(): PrismaClient;
    static get typeORMClient(): TypeORMEntityManager;
    static get drizzleClient(): DrizzleClient;
    static getConfig<T>(key: string): T | undefined;
    static getConfig<T>(key: string, defaultValue: T): T;
    static getWorkflowStatus(workflowID: string): Promise<import("./workflow").WorkflowStatus | null>;
    static retrieveWorkflow(workflowID: string): WorkflowHandle<unknown>;
    static getWorkflows(input: GetWorkflowsInput): Promise<GetWorkflowsOutput>;
    static getWorkflowQueue(input: GetWorkflowQueueInput): Promise<GetWorkflowQueueOutput>;
    static sleepms(durationMS: number): Promise<void>;
    static sleepSeconds(durationSec: number): Promise<void>;
    static sleep(durationMS: number): Promise<void>;
    static withNextWorkflowID<R>(wfid: string, callback: () => Promise<R>): Promise<R>;
    static withTracedContext<R>(callerName: string, span: Span, request: HTTPRequest, callback: () => Promise<R>): Promise<R>;
    static withAuthedContext<R>(authedUser: string, authedRoles: string[], callback: () => Promise<R>): Promise<R>;
    static withNamedContext<R>(callerName: string, callback: () => Promise<R>): Promise<R>;
    static withWorkflowQueue<R>(wfq: string, callback: () => Promise<R>): Promise<R>;
    static startWorkflow<T extends ConfiguredInstance>(targetClass: T, params?: StartWorkflowParams): InvokeFunctionsAsyncInst<T>;
    static startWorkflow<T extends object>(targetClass: T, params?: StartWorkflowParams): InvokeFunctionsAsync<T>;
    static proxyInvokeWF<T extends object>(object: T, configuredInstance: ConfiguredInstance | null, inParams?: StartWorkflowParams): InvokeFunctionsAsync<T>;
    static invoke<T extends ConfiguredInstance>(targetCfg: T): InvokeFuncsInst<T>;
    static invoke<T extends object>(targetClass: T): InvokeFuncs<T>;
    static send<T>(destinationID: string, message: T, topic?: string): Promise<void>;
    static recv<T>(topic?: string, timeoutSeconds?: number): Promise<T | null>;
    static setEvent<T>(key: string, value: T): Promise<void>;
    static getEvent<T>(workflowID: string, key: string, timeoutSeconds?: number): Promise<T | null>;
    static scheduled(schedulerConfig: SchedulerConfig): <This, Return>(target: object, propertyKey: string, inDescriptor: TypedPropertyDescriptor<(this: This, ...args: ScheduledArgs) => Promise<Return>>) => TypedPropertyDescriptor<(this: This, args_0: Date, args_1: Date) => Promise<Return>>;
    static workflow(config?: WorkflowConfig): <This, Args extends unknown[], Return>(target: object, propertyKey: string, inDescriptor: TypedPropertyDescriptor<(this: This, ...args: Args) => Promise<Return>>) => TypedPropertyDescriptor<(this: This, ...args: Args) => Promise<Return>>;
    static transaction(config?: TransactionConfig): <This, Args extends unknown[], Return>(target: object, propertyKey: string, inDescriptor: TypedPropertyDescriptor<(this: This, ...args: Args) => Promise<Return>>) => TypedPropertyDescriptor<(this: This, ...args: Args) => Promise<Return>>;
    static step(config?: StepConfig): <This, Args extends unknown[], Return>(target: object, propertyKey: string, inDescriptor: TypedPropertyDescriptor<(this: This, ...args: Args) => Promise<Return>>) => TypedPropertyDescriptor<(this: This, ...args: Args) => Promise<Return>>;
    static getApi(url: string): <This, Args extends unknown[], Return>(target: object, propertyKey: string, inDescriptor: TypedPropertyDescriptor<(this: This, ...args: Args) => Promise<Return>>) => TypedPropertyDescriptor<(this: This, ...args: Args) => Promise<Return>>;
    static postApi(url: string): <This, Args extends unknown[], Return>(target: object, propertyKey: string, inDescriptor: TypedPropertyDescriptor<(this: This, ...args: Args) => Promise<Return>>) => TypedPropertyDescriptor<(this: This, ...args: Args) => Promise<Return>>;
    static putApi(url: string): <This, Args extends unknown[], Return>(target: object, propertyKey: string, inDescriptor: TypedPropertyDescriptor<(this: This, ...args: Args) => Promise<Return>>) => TypedPropertyDescriptor<(this: This, ...args: Args) => Promise<Return>>;
    static patchApi(url: string): <This, Args extends unknown[], Return>(target: object, propertyKey: string, inDescriptor: TypedPropertyDescriptor<(this: This, ...args: Args) => Promise<Return>>) => TypedPropertyDescriptor<(this: This, ...args: Args) => Promise<Return>>;
    static deleteApi(url: string): <This, Args extends unknown[], Return>(target: object, propertyKey: string, inDescriptor: TypedPropertyDescriptor<(this: This, ...args: Args) => Promise<Return>>) => TypedPropertyDescriptor<(this: This, ...args: Args) => Promise<Return>>;
    static defaultRequiredRole(anyOf: string[]): <T extends new (...args: any[]) => object>(ctor: T) => void;
    static requiredRole(anyOf: string[]): <This, Args extends unknown[], Return>(target: object, propertyKey: string, inDescriptor: TypedPropertyDescriptor<(this: This, ...args: Args) => Promise<Return>>) => TypedPropertyDescriptor<(this: This, ...args: Args) => Promise<Return>>;
    static configureInstance<R extends ConfiguredInstance, T extends unknown[]>(cls: new (name: string, ...args: T) => R, name: string, ...args: T): R;
    static registerAndWrapContextFreeFunction<This, Args extends unknown[], Return>(target: object, propertyKey: string, descriptor: TypedPropertyDescriptor<(this: This, ...args: Args) => Promise<Return>>): {
        descriptor: TypedPropertyDescriptor<(this: This, ...args: Args) => Promise<Return>>;
        registration: MethodRegistration<This, Args, Return>;
    };
    static executeWorkflowById(workflowId: string, startNewWorkflow?: boolean): Promise<WorkflowHandle<unknown>>;
    static recoverPendingWorkflows(executorIDs?: string[]): Promise<WorkflowHandle<unknown>[]>;
}
export {};
//# sourceMappingURL=dbos.d.ts.map