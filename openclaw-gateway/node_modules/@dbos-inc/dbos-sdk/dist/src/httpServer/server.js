"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DBOSHttpServer = exports.DeactivateUrl = exports.PerfUrl = exports.HealthUrl = exports.WorkflowRecoveryUrl = exports.WorkflowUUIDHeader = void 0;
const koa_1 = __importDefault(require("koa"));
const router_1 = __importDefault(require("@koa/router"));
const bodyparser_1 = require("@koa/bodyparser");
const cors_1 = __importDefault(require("@koa/cors"));
const handler_1 = require("./handler");
const handlerTypes_1 = require("./handlerTypes");
const error_1 = require("../error");
const api_1 = require("@opentelemetry/api");
const net = __importStar(require("net"));
const perf_hooks_1 = require("perf_hooks");
const utils_1 = require("../utils");
const context_1 = require("../context");
exports.WorkflowUUIDHeader = "dbos-idempotency-key";
exports.WorkflowRecoveryUrl = "/dbos-workflow-recovery";
exports.HealthUrl = "/dbos-healthz";
exports.PerfUrl = "/dbos-perf";
// FIXME this should be /dbos-deactivate to be consistent with other endpoints.
exports.DeactivateUrl = "/deactivate";
class DBOSHttpServer {
    dbosExec;
    app;
    adminApp;
    applicationRouter;
    logger;
    static nRegisteredEndpoints = 0;
    static instance = undefined;
    /**
     * Create a Koa app.
     * @param dbosExec User pass in an DBOS workflow executor instance.
     * TODO: maybe call dbosExec.init() somewhere in this class?
     */
    constructor(dbosExec) {
        this.dbosExec = dbosExec;
        this.applicationRouter = new router_1.default();
        this.logger = dbosExec.logger;
        this.app = new koa_1.default();
        this.adminApp = DBOSHttpServer.setupAdminApp(this.dbosExec);
        DBOSHttpServer.registerDecoratedEndpoints(this.dbosExec, this.applicationRouter, this.app);
        this.app.use(this.applicationRouter.routes()).use(this.applicationRouter.allowedMethods());
        DBOSHttpServer.instance = this;
    }
    static setupAdminApp(dbosExec) {
        const adminRouter = new router_1.default();
        const adminApp = new koa_1.default();
        adminApp.use((0, bodyparser_1.bodyParser)());
        adminApp.use((0, cors_1.default)());
        // Register HTTP endpoints.
        DBOSHttpServer.registerHealthEndpoint(dbosExec, adminRouter);
        DBOSHttpServer.registerRecoveryEndpoint(dbosExec, adminRouter);
        DBOSHttpServer.registerPerfEndpoint(dbosExec, adminRouter);
        DBOSHttpServer.registerDeactivateEndpoint(dbosExec, adminRouter);
        adminApp.use(adminRouter.routes()).use(adminRouter.allowedMethods());
        return adminApp;
    }
    /**
     * Register HTTP endpoints and attach to the app. Then start the server at the given port.
     * @param port
     */
    async listen(port, adminPort) {
        const appServer = await this.appListen(port);
        // TODO we should check adminPort as well.  This is done elsewhere though...
        const adminServer = this.adminApp.listen(adminPort, () => {
            this.logger.info(`DBOS Admin Server is running at http://localhost:${adminPort}`);
        });
        return { appServer: appServer, adminServer: adminServer };
    }
    async appListen(port) {
        await DBOSHttpServer.checkPortAvailabilityIPv4Ipv6(port, this.logger);
        const appServer = DBOSHttpServer.nRegisteredEndpoints === 0 ? undefined : this.app.listen(port, () => {
            this.logger.info(`DBOS Server is running at http://localhost:${port}`);
        });
        return appServer;
    }
    static async checkPortAvailabilityIPv4Ipv6(port, logger) {
        try {
            await this.checkPortAvailability(port, "127.0.0.1");
        }
        catch (error) {
            const err = error;
            if (err.code === "EADDRINUSE") {
                logger.error(`Port ${port} is already used for IPv4 address "127.0.0.1". Please use the -p option to choose another port.\n${err.message}`);
                process.exit(1);
            }
            else {
                logger.warn(`Error occurred while checking port availability for IPv4 address "127.0.0.1" : ${err.code}\n${err.message}`);
            }
        }
        try {
            await this.checkPortAvailability(port, "::1");
        }
        catch (error) {
            const err = error;
            if (err.code === "EADDRINUSE") {
                logger.error(`Port ${port} is already used for IPv6 address "::1". Please use the -p option to choose another port.\n${err.message}`);
                process.exit(1);
            }
            else {
                logger.warn(`Error occurred while checking port availability for IPv6 address "::1" : ${err.code}\n${err.message}`);
            }
        }
    }
    static async checkPortAvailability(port, host) {
        return new Promise((resolve, reject) => {
            const server = new net.Server();
            server.on('error', (error) => {
                reject(error);
            });
            server.on('listening', () => {
                server.close();
                resolve();
            });
            server.listen({ port: port, host: host }, () => {
                resolve();
            });
        });
    }
    /**
     * Health check endpoint.
     */
    static registerHealthEndpoint(dbosExec, router) {
        // Handler function that parses request for recovery.
        const healthHandler = async (koaCtxt, koaNext) => {
            koaCtxt.body = "healthy";
            await koaNext();
        };
        router.get(exports.HealthUrl, healthHandler);
        dbosExec.logger.debug(`DBOS Server Registered Healthz GET ${exports.HealthUrl}`);
    }
    /**
     * Register workflow recovery endpoint.
     * Receives a list of executor IDs and returns a list of workflowUUIDs.
     */
    static registerRecoveryEndpoint(dbosExec, router) {
        // Handler function that parses request for recovery.
        const recoveryHandler = async (koaCtxt, koaNext) => {
            const executorIDs = koaCtxt.request.body;
            dbosExec.logger.info("Recovering workflows for executors: " + executorIDs.toString());
            const recoverHandles = await dbosExec.recoverPendingWorkflows(executorIDs);
            // Return a list of workflowUUIDs being recovered.
            koaCtxt.body = await Promise.allSettled(recoverHandles.map((i) => i.getWorkflowUUID())).then((results) => results.filter((i) => i.status === "fulfilled").map((i) => i.value));
            await koaNext();
        };
        router.post(exports.WorkflowRecoveryUrl, recoveryHandler);
        dbosExec.logger.debug(`DBOS Server Registered Recovery POST ${exports.WorkflowRecoveryUrl}`);
    }
    /**
     * Register performance endpoint.
     * Returns information on VM performance since last call.
     */
    static registerPerfEndpoint(dbosExec, router) {
        let lastELU = perf_hooks_1.performance.eventLoopUtilization();
        const perfHandler = async (koaCtxt, koaNext) => {
            const currELU = perf_hooks_1.performance.eventLoopUtilization();
            const elu = perf_hooks_1.performance.eventLoopUtilization(currELU, lastELU);
            koaCtxt.body = elu;
            lastELU = currELU;
            await koaNext();
        };
        router.get(exports.PerfUrl, perfHandler);
        dbosExec.logger.debug(`DBOS Server Registered Perf GET ${exports.HealthUrl}`);
    }
    /**
     * Register Deactivate endpoint.
     * Deactivate consumers so that they don't start new workflows.
     *
     */
    static registerDeactivateEndpoint(dbosExec, router) {
        const deactivateHandler = async (koaCtxt, koaNext) => {
            await dbosExec.deactivateEventReceivers();
            dbosExec.logger.info("Deactivating Event Receivers");
            koaCtxt.body = "Deactivated";
            await koaNext();
        };
        router.get(exports.DeactivateUrl, deactivateHandler);
        dbosExec.logger.debug(`DBOS Server Registered Deactivate GET ${exports.DeactivateUrl}`);
    }
    /**
     * Register decorated functions as HTTP endpoints.
     */
    static registerDecoratedEndpoints(dbosExec, router, app) {
        const globalMiddlewares = new Set();
        // Register user declared endpoints, wrap around the endpoint with request parsing and response.
        DBOSHttpServer.nRegisteredEndpoints = 0;
        dbosExec.registeredOperations.forEach((registeredOperation) => {
            const ro = registeredOperation;
            if (ro.apiURL) {
                if (ro.isInstance) {
                    dbosExec.logger.warn(`Operation ${ro.className}/${ro.name} is registered with an endpoint (${ro.apiURL}) but cannot be invoked.`);
                    return;
                }
                ++DBOSHttpServer.nRegisteredEndpoints;
                const defaults = ro.defaults;
                // Check if we need to apply a custom CORS
                if (defaults.koaCors) {
                    router.all(ro.apiURL, defaults.koaCors); // Use router.all to register with all methods including preflight requests
                }
                else {
                    if (dbosExec.config.http?.cors_middleware ?? true) {
                        router.all(ro.apiURL, (0, cors_1.default)({
                            credentials: dbosExec.config.http?.credentials ?? true,
                            origin: (o) => {
                                const whitelist = dbosExec.config.http?.allowed_origins;
                                const origin = o.request.header.origin ?? '*';
                                if (whitelist && whitelist.length > 0) {
                                    return (whitelist.includes(origin) ? origin : '');
                                }
                                return o.request.header.origin || '*';
                            },
                            allowMethods: 'GET,HEAD,PUT,POST,DELETE,PATCH,OPTIONS',
                            allowHeaders: ['Origin', 'X-Requested-With', 'Content-Type', 'Accept', 'Authorization'],
                        }));
                    }
                }
                // Check if we need to apply a custom body parser
                if (defaults.koaBodyParser) {
                    router.use(ro.apiURL, defaults.koaBodyParser);
                }
                else {
                    router.use(ro.apiURL, (0, bodyparser_1.bodyParser)());
                }
                // Check if we need to apply any Koa middleware.
                if (defaults?.koaMiddlewares) {
                    defaults.koaMiddlewares.forEach((koaMiddleware) => {
                        dbosExec.logger.debug(`DBOS Server applying middleware ${koaMiddleware.name} to ${ro.apiURL}`);
                        router.use(ro.apiURL, koaMiddleware);
                    });
                }
                if (defaults?.koaGlobalMiddlewares) {
                    defaults.koaGlobalMiddlewares.forEach((koaMiddleware) => {
                        if (globalMiddlewares.has(koaMiddleware)) {
                            return;
                        }
                        dbosExec.logger.debug(`DBOS Server applying middleware ${koaMiddleware.name} globally`);
                        globalMiddlewares.add(koaMiddleware);
                        app.use(koaMiddleware);
                    });
                }
                // Wrapper function that parses request and send response.
                const wrappedHandler = async (koaCtxt, koaNext) => {
                    const oc = new handler_1.HandlerContextImpl(dbosExec, koaCtxt);
                    try {
                        // Check for auth first
                        if (defaults?.authMiddleware) {
                            const res = await defaults.authMiddleware({
                                name: ro.name,
                                requiredRole: ro.getRequiredRoles(),
                                koaContext: koaCtxt,
                                logger: oc.logger,
                                span: oc.span,
                                getConfig: (key, def) => {
                                    return oc.getConfig(key, def);
                                },
                                query: (query, ...args) => {
                                    return dbosExec.userDatabase.queryFunction(query, ...args);
                                },
                            });
                            if (res) {
                                oc.authenticatedUser = res.authenticatedUser;
                                oc.authenticatedRoles = res.authenticatedRoles;
                            }
                        }
                        // Parse the arguments.
                        const args = [];
                        ro.args.forEach((marg, idx) => {
                            marg.argSource = marg.argSource ?? handlerTypes_1.ArgSources.DEFAULT; // Assign a default value.
                            if (idx === 0 && ro.passContext) {
                                return; // Do not parse the context.
                            }
                            let foundArg = undefined;
                            const isQueryMethod = ro.apiType === handlerTypes_1.APITypes.GET || ro.apiType === handlerTypes_1.APITypes.DELETE;
                            const isBodyMethod = ro.apiType === handlerTypes_1.APITypes.POST || ro.apiType === handlerTypes_1.APITypes.PUT || ro.apiType === handlerTypes_1.APITypes.PATCH;
                            if ((isQueryMethod && marg.argSource === handlerTypes_1.ArgSources.DEFAULT) || marg.argSource === handlerTypes_1.ArgSources.QUERY) {
                                foundArg = koaCtxt.request.query[marg.name];
                                if (foundArg !== undefined) {
                                    args.push(foundArg);
                                }
                            }
                            else if ((isBodyMethod && marg.argSource === handlerTypes_1.ArgSources.DEFAULT) || marg.argSource === handlerTypes_1.ArgSources.BODY) {
                                if (!koaCtxt.request.body) {
                                    throw new error_1.DBOSDataValidationError(`Argument ${marg.name} requires a method body.`);
                                }
                                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment
                                foundArg = koaCtxt.request.body[marg.name];
                                if (foundArg !== undefined) {
                                    args.push(foundArg);
                                }
                            }
                            // Try to parse the argument from the URL if nothing found.
                            if (foundArg === undefined) {
                                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                                args.push(koaCtxt.params[marg.name]);
                            }
                            //console.log(`found arg ${marg.name} ${idx} ${args[idx-1]}`);
                        });
                        // Extract workflow UUID from headers (if any).
                        // We pass in the specified workflow UUID to workflows and transactions, but doesn't restrict how handlers use it.
                        const headerWorkflowUUID = koaCtxt.get(exports.WorkflowUUIDHeader);
                        // Finally, invoke the transaction/workflow/plain function and properly set HTTP response.
                        // If functions return successfully and hasn't set the body, we set the body to the function return value. The status code will be automatically set to 200 or 204 (if the body is null/undefined).
                        // In case of an exception:
                        // - If a client-side error is thrown, we return 400.
                        // - If an error contains a `status` field, we return the specified status code.
                        // - Otherwise, we return 500.
                        // configuredInstance is currently null; we don't allow configured handlers now.
                        const wfParams = { parentCtx: oc, workflowUUID: headerWorkflowUUID, configuredInstance: null };
                        if (ro.txnConfig) {
                            koaCtxt.body = await dbosExec.transaction(ro.registeredFunction, wfParams, ...args);
                        }
                        else if (ro.workflowConfig) {
                            koaCtxt.body = await (await dbosExec.workflow(ro.registeredFunction, wfParams, ...args)).getResult();
                        }
                        else if (ro.commConfig) {
                            koaCtxt.body = await dbosExec.external(ro.registeredFunction, wfParams, ...args);
                        }
                        else {
                            // Directly invoke the handler code.
                            let cresult;
                            await (0, context_1.runWithHandlerContext)(oc, async () => {
                                if (ro.passContext) {
                                    cresult = await ro.invoke(undefined, [oc, ...args]);
                                }
                                else {
                                    cresult = await ro.invoke(undefined, [...args]);
                                }
                            });
                            const retValue = cresult;
                            // Set the body to the return value unless the body is already set by the handler.
                            if (koaCtxt.body === undefined) {
                                koaCtxt.body = retValue;
                            }
                        }
                        oc.span.setStatus({ code: api_1.SpanStatusCode.OK });
                    }
                    catch (e) {
                        if (e instanceof Error) {
                            const annotated_e = e;
                            if (annotated_e.dbos_already_logged !== true) {
                                oc.logger.error(e);
                            }
                            oc.span.setStatus({ code: api_1.SpanStatusCode.ERROR, message: e.message });
                            let st = e?.status || 500;
                            const dbosErrorCode = e?.dbosErrorCode;
                            if (dbosErrorCode && (0, error_1.isClientError)(dbosErrorCode)) {
                                st = 400; // Set to 400: client-side error.
                            }
                            koaCtxt.status = st;
                            koaCtxt.message = e.message;
                            koaCtxt.body = {
                                status: st,
                                message: e.message,
                                details: e,
                            };
                        }
                        else {
                            // FIXME we should have a standard, user friendly message for errors that are not instances of Error.
                            // using stringify() will not produce a pretty output, because our format function uses stringify() too.
                            oc.logger.error(utils_1.DBOSJSON.stringify(e));
                            oc.span.setStatus({ code: api_1.SpanStatusCode.ERROR, message: utils_1.DBOSJSON.stringify(e) });
                            koaCtxt.body = e;
                            koaCtxt.status = 500;
                        }
                    }
                    finally {
                        oc.W3CTraceContextPropagator.inject(api_1.trace.setSpanContext(api_1.ROOT_CONTEXT, oc.span.spanContext()), {
                            context: koaCtxt,
                        }, {
                            set: (carrier, key, value) => {
                                carrier.context.set(key, value);
                            },
                        });
                        dbosExec.tracer.endSpan(oc.span);
                        await koaNext();
                    }
                };
                // Actually register the endpoint.
                switch (ro.apiType) {
                    case handlerTypes_1.APITypes.GET:
                        router.get(ro.apiURL, wrappedHandler);
                        dbosExec.logger.debug(`DBOS Server Registered GET ${ro.apiURL}`);
                        break;
                    case handlerTypes_1.APITypes.POST:
                        router.post(ro.apiURL, wrappedHandler);
                        dbosExec.logger.debug(`DBOS Server Registered POST ${ro.apiURL}`);
                        break;
                    case handlerTypes_1.APITypes.PUT:
                        router.put(ro.apiURL, wrappedHandler);
                        dbosExec.logger.debug(`DBOS Server Registered PUT ${ro.apiURL}`);
                        break;
                    case handlerTypes_1.APITypes.PATCH:
                        router.patch(ro.apiURL, wrappedHandler);
                        dbosExec.logger.debug(`DBOS Server Registered PATCH ${ro.apiURL}`);
                        break;
                    case handlerTypes_1.APITypes.DELETE:
                        router.delete(ro.apiURL, wrappedHandler);
                        dbosExec.logger.debug(`DBOS Server Registered DELETE ${ro.apiURL}`);
                        break;
                    default:
                        (0, utils_1.exhaustiveCheckGuard)(ro.apiType);
                }
            }
        });
    }
}
exports.DBOSHttpServer = DBOSHttpServer;
//# sourceMappingURL=server.js.map