import { MethodParameter, MethodRegistrationBase, ConfiguredInstance } from "../decorators";
import { DBOSExecutor } from "../dbos-executor";
import { DBOSContext, DBOSContextImpl } from "../context";
import Koa from "koa";
import { TailParameters, WorkflowHandle, WorkflowContext, WFInvokeFuncs, WFInvokeFuncsInst, GetWorkflowsInput, GetWorkflowsOutput } from "../workflow";
import { W3CTraceContextPropagator } from "@opentelemetry/core";
import { APITypes, ArgSources } from "./handlerTypes";
import { WorkflowQueue } from "../wfqueue";
type WFFunc = (ctxt: WorkflowContext, ...args: any[]) => Promise<unknown>;
export type InvokeFuncs<T> = WFInvokeFuncs<T> & AsyncHandlerWfFuncs<T>;
export type InvokeFuncsInst<T> = WFInvokeFuncsInst<T>;
export type AsyncHandlerWfFuncs<T> = T extends ConfiguredInstance ? never : {
    [P in keyof T as T[P] extends WFFunc ? P : never]: T[P] extends WFFunc ? (...args: TailParameters<T[P]>) => Promise<WorkflowHandle<Awaited<ReturnType<T[P]>>>> : never;
};
export type SyncHandlerWfFuncs<T> = T extends ConfiguredInstance ? never : {
    [P in keyof T as T[P] extends WFFunc ? P : never]: T[P] extends WFFunc ? (...args: TailParameters<T[P]>) => Promise<Awaited<ReturnType<T[P]>>> : never;
};
export type AsyncHandlerWfFuncInst<T> = T extends ConfiguredInstance ? {
    [P in keyof T as T[P] extends WFFunc ? P : never]: T[P] extends WFFunc ? (...args: TailParameters<T[P]>) => Promise<WorkflowHandle<Awaited<ReturnType<T[P]>>>> : never;
} : never;
export type SyncHandlerWfFuncsInst<T> = T extends ConfiguredInstance ? {
    [P in keyof T as T[P] extends WFFunc ? P : never]: T[P] extends WFFunc ? (...args: TailParameters<T[P]>) => Promise<Awaited<ReturnType<T[P]>>> : never;
} : never;
export interface HandlerContext extends DBOSContext {
    readonly koaContext: Koa.Context;
    invoke<T extends ConfiguredInstance>(targetCfg: T, workflowUUID?: string): InvokeFuncsInst<T>;
    invoke<T extends object>(targetClass: T, workflowUUID?: string): InvokeFuncs<T>;
    invokeWorkflow<T extends ConfiguredInstance>(targetCfg: T, workflowUUID?: string): SyncHandlerWfFuncsInst<T>;
    invokeWorkflow<T extends object>(targetClass: T, workflowUUID?: string): SyncHandlerWfFuncs<T>;
    startWorkflow<T extends ConfiguredInstance>(targetCfg: T, workflowUUID?: string, queue?: WorkflowQueue): AsyncHandlerWfFuncInst<T>;
    startWorkflow<T extends object>(targetClass: T, workflowUUID?: string, queue?: WorkflowQueue): AsyncHandlerWfFuncs<T>;
    retrieveWorkflow<R>(workflowUUID: string): WorkflowHandle<R>;
    send<T>(destinationUUID: string, message: T, topic?: string, idempotencyKey?: string): Promise<void>;
    getEvent<T>(workflowUUID: string, key: string, timeoutSeconds?: number): Promise<T | null>;
    getWorkflows(input: GetWorkflowsInput): Promise<GetWorkflowsOutput>;
}
export declare class HandlerContextImpl extends DBOSContextImpl implements HandlerContext {
    #private;
    readonly koaContext: Koa.Context;
    readonly W3CTraceContextPropagator: W3CTraceContextPropagator;
    constructor(dbosExec: DBOSExecutor, koaContext: Koa.Context);
    send<T>(destinationUUID: string, message: T, topic?: string, idempotencyKey?: string): Promise<void>;
    getEvent<T>(workflowUUID: string, key: string, timeoutSeconds?: number): Promise<T | null>;
    retrieveWorkflow<R>(workflowUUID: string): WorkflowHandle<R>;
    /**
     * Generate a proxy object for the provided class that wraps direct calls (i.e. OpClass.someMethod(param))
     * to use WorkflowContext.Transaction(OpClass.someMethod, param);
     */
    mainInvoke<T extends object>(object: T, workflowUUID: string | undefined, asyncWf: boolean, configuredInstance: ConfiguredInstance | null, queue?: WorkflowQueue): InvokeFuncs<T>;
    invoke<T extends object>(object: T | ConfiguredInstance, workflowUUID?: string): InvokeFuncs<T> | InvokeFuncsInst<T>;
    startWorkflow<T extends object>(object: T | ConfiguredInstance, workflowUUID?: string, queue?: WorkflowQueue): AsyncHandlerWfFuncs<T> | AsyncHandlerWfFuncInst<T>;
    invokeWorkflow<T extends object>(object: T | ConfiguredInstance, workflowUUID?: string): SyncHandlerWfFuncs<T> | SyncHandlerWfFuncsInst<T>;
    getWorkflows(input: GetWorkflowsInput): Promise<GetWorkflowsOutput>;
}
export interface HandlerRegistrationBase extends MethodRegistrationBase {
    apiType: APITypes;
    apiURL: string;
    args: HandlerParameter[];
}
export declare class HandlerParameter extends MethodParameter {
    argSource: ArgSources;
    constructor(idx: number, at: Function);
}
export declare function GetApi(url: string): <This, Ctx extends DBOSContext, Args extends unknown[], Return>(target: object, propertyKey: string, inDescriptor: TypedPropertyDescriptor<(this: This, ctx: Ctx, ...args: Args) => Promise<Return>>) => TypedPropertyDescriptor<(this: This, ctx: Ctx, ...args: Args) => Promise<Return>>;
export declare function PostApi(url: string): <This, Ctx extends DBOSContext, Args extends unknown[], Return>(target: object, propertyKey: string, inDescriptor: TypedPropertyDescriptor<(this: This, ctx: Ctx, ...args: Args) => Promise<Return>>) => TypedPropertyDescriptor<(this: This, ctx: Ctx, ...args: Args) => Promise<Return>>;
export declare function PutApi(url: string): <This, Ctx extends DBOSContext, Args extends unknown[], Return>(target: object, propertyKey: string, inDescriptor: TypedPropertyDescriptor<(this: This, ctx: Ctx, ...args: Args) => Promise<Return>>) => TypedPropertyDescriptor<(this: This, ctx: Ctx, ...args: Args) => Promise<Return>>;
export declare function PatchApi(url: string): <This, Ctx extends DBOSContext, Args extends unknown[], Return>(target: object, propertyKey: string, inDescriptor: TypedPropertyDescriptor<(this: This, ctx: Ctx, ...args: Args) => Promise<Return>>) => TypedPropertyDescriptor<(this: This, ctx: Ctx, ...args: Args) => Promise<Return>>;
export declare function DeleteApi(url: string): <This, Ctx extends DBOSContext, Args extends unknown[], Return>(target: object, propertyKey: string, inDescriptor: TypedPropertyDescriptor<(this: This, ctx: Ctx, ...args: Args) => Promise<Return>>) => TypedPropertyDescriptor<(this: This, ctx: Ctx, ...args: Args) => Promise<Return>>;
export declare function ArgSource(source: ArgSources): (target: object, propertyKey: string | symbol, parameterIndex: number) => void;
export {};
//# sourceMappingURL=handler.d.ts.map