"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArgSource = exports.DeleteApi = exports.PatchApi = exports.PutApi = exports.PostApi = exports.GetApi = exports.HandlerParameter = exports.HandlerContextImpl = void 0;
const decorators_1 = require("../decorators");
const dbos_executor_1 = require("../dbos-executor");
const context_1 = require("../context");
const core_1 = require("@opentelemetry/core");
const api_1 = require("@opentelemetry/api");
const handlerTypes_1 = require("./handlerTypes");
const middleware_1 = require("./middleware");
// TODO: this should be refactored to not take a koaContext in.
class HandlerContextImpl extends context_1.DBOSContextImpl {
    koaContext;
    #dbosExec;
    W3CTraceContextPropagator;
    constructor(dbosExec, koaContext) {
        // Retrieve or generate the request ID
        const requestID = (0, middleware_1.getOrGenerateRequestID)(koaContext.request.headers);
        koaContext.set(middleware_1.RequestIDHeader, requestID);
        // If present, retrieve the trace context from the request
        const httpTracer = new core_1.W3CTraceContextPropagator();
        const extractedSpanContext = api_1.trace.getSpanContext(httpTracer.extract(api_1.ROOT_CONTEXT, koaContext.request.headers, api_1.defaultTextMapGetter));
        let span;
        const spanAttributes = {
            operationType: dbos_executor_1.OperationType.HANDLER,
            requestID: requestID,
            requestIP: koaContext.request.ip,
            requestURL: koaContext.request.url,
            requestMethod: koaContext.request.method,
        };
        if (extractedSpanContext === undefined) {
            span = dbosExec.tracer.startSpan(koaContext.url, spanAttributes);
        }
        else {
            extractedSpanContext.isRemote = true;
            span = dbosExec.tracer.startSpanWithContext(extractedSpanContext, koaContext.url, spanAttributes);
        }
        super(koaContext.url, span, dbosExec.logger);
        this.koaContext = koaContext;
        // If running in DBOS Cloud, set the executor ID
        if (process.env.DBOS__VMID) {
            this.executorID = process.env.DBOS__VMID;
        }
        this.W3CTraceContextPropagator = httpTracer;
        this.request = {
            headers: koaContext.request.headers,
            rawHeaders: koaContext.req.rawHeaders,
            params: koaContext.params,
            body: koaContext.request.body,
            rawBody: koaContext.request.rawBody,
            query: koaContext.request.query,
            querystring: koaContext.request.querystring,
            url: koaContext.request.url,
            ip: koaContext.request.ip,
            requestID: requestID,
        };
        this.applicationConfig = dbosExec.config.application;
        this.#dbosExec = dbosExec;
    }
    ///////////////////////
    /* PUBLIC INTERFACE  */
    ///////////////////////
    async send(destinationUUID, message, topic, idempotencyKey) {
        return this.#dbosExec.send(destinationUUID, message, topic, idempotencyKey);
    }
    async getEvent(workflowUUID, key, timeoutSeconds = dbos_executor_1.DBOSExecutor.defaultNotificationTimeoutSec) {
        return this.#dbosExec.getEvent(workflowUUID, key, timeoutSeconds);
    }
    retrieveWorkflow(workflowUUID) {
        return this.#dbosExec.retrieveWorkflow(workflowUUID);
    }
    /**
     * Generate a proxy object for the provided class that wraps direct calls (i.e. OpClass.someMethod(param))
     * to use WorkflowContext.Transaction(OpClass.someMethod, param);
     */
    mainInvoke(object, workflowUUID, asyncWf, configuredInstance, queue) {
        const ops = (0, decorators_1.getRegisteredOperations)(object);
        const proxy = {};
        const params = { workflowUUID: workflowUUID, parentCtx: this, configuredInstance, queueName: queue?.name };
        for (const op of ops) {
            if (asyncWf) {
                proxy[op.name] = op.txnConfig
                    ? (...args) => this.#transaction(op.registeredFunction, params, ...args)
                    : op.workflowConfig
                        ? (...args) => this.#workflow(op.registeredFunction, params, ...args)
                        : op.commConfig
                            ? (...args) => this.#external(op.registeredFunction, params, ...args)
                            : op.procConfig
                                ? (...args) => this.#procedure(op.registeredFunction, params, ...args)
                                : undefined;
            }
            else {
                proxy[op.name] = op.workflowConfig
                    ? (...args) => this.#workflow(op.registeredFunction, params, ...args).then((handle) => handle.getResult())
                    : undefined;
            }
        }
        return proxy;
    }
    invoke(object, workflowUUID) {
        if (typeof object === 'function') {
            return this.mainInvoke(object, workflowUUID, true, null, undefined);
        }
        else {
            const targetInst = object;
            return this.mainInvoke(targetInst, workflowUUID, true, targetInst, undefined);
        }
    }
    startWorkflow(object, workflowUUID, queue) {
        if (typeof object === 'function') {
            return this.mainInvoke(object, workflowUUID, true, null, queue);
        }
        else {
            const targetInst = object;
            return this.mainInvoke(targetInst, workflowUUID, true, targetInst, queue);
        }
    }
    invokeWorkflow(object, workflowUUID) {
        if (typeof object === 'function') {
            return this.mainInvoke(object, workflowUUID, false, null, undefined);
        }
        else {
            const targetInst = object;
            return this.mainInvoke(targetInst, workflowUUID, false, targetInst, undefined);
        }
    }
    async getWorkflows(input) {
        return this.#dbosExec.systemDatabase.getWorkflows(input);
    }
    //////////////////////
    /* PRIVATE METHODS */
    /////////////////////
    async #workflow(wf, params, ...args) {
        return this.#dbosExec.workflow(wf, params, ...args);
    }
    async #transaction(txn, params, ...args) {
        return this.#dbosExec.transaction(txn, params, ...args);
    }
    async #external(stepFn, params, ...args) {
        return this.#dbosExec.external(stepFn, params, ...args);
    }
    async #procedure(proc, params, ...args) {
        return this.#dbosExec.procedure(proc, params, ...args);
    }
}
exports.HandlerContextImpl = HandlerContextImpl;
class HandlerParameter extends decorators_1.MethodParameter {
    argSource = handlerTypes_1.ArgSources.DEFAULT;
    // eslint-disable-next-line @typescript-eslint/ban-types
    constructor(idx, at) {
        super(idx, at);
    }
}
exports.HandlerParameter = HandlerParameter;
/////////////////////////
/* ENDPOINT DECORATORS */
/////////////////////////
function generateApiDec(verb, url) {
    return function apidec(target, propertyKey, inDescriptor) {
        const { descriptor, registration } = (0, decorators_1.registerAndWrapFunction)(target, propertyKey, inDescriptor);
        const handlerRegistration = registration;
        handlerRegistration.apiURL = url;
        handlerRegistration.apiType = verb;
        return descriptor;
    };
}
function GetApi(url) {
    return generateApiDec(handlerTypes_1.APITypes.GET, url);
}
exports.GetApi = GetApi;
function PostApi(url) {
    return generateApiDec(handlerTypes_1.APITypes.POST, url);
}
exports.PostApi = PostApi;
function PutApi(url) {
    return generateApiDec(handlerTypes_1.APITypes.PUT, url);
}
exports.PutApi = PutApi;
function PatchApi(url) {
    return generateApiDec(handlerTypes_1.APITypes.PATCH, url);
}
exports.PatchApi = PatchApi;
function DeleteApi(url) {
    return generateApiDec(handlerTypes_1.APITypes.DELETE, url);
}
exports.DeleteApi = DeleteApi;
///////////////////////////////////
/* ENDPOINT PARAMETER DECORATORS */
///////////////////////////////////
function ArgSource(source) {
    return function (target, propertyKey, parameterIndex) {
        const existingParameters = (0, decorators_1.getOrCreateMethodArgsRegistration)(target, propertyKey);
        const curParam = existingParameters[parameterIndex];
        curParam.argSource = source;
    };
}
exports.ArgSource = ArgSource;
//# sourceMappingURL=handler.js.map