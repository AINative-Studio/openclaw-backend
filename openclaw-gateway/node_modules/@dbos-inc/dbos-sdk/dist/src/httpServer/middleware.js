"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.expressTracingMiddleware = exports.koaTracingMiddleware = exports.createHTTPSpan = exports.getOrGenerateRequestID = exports.RequestIDHeader = exports.OpenApiSecurityScheme = exports.KoaGlobalMiddleware = exports.KoaMiddleware = exports.KoaCors = exports.KoaBodyParser = exports.Authentication = exports.MiddlewareClassRegistration = void 0;
const decorators_1 = require("../decorators");
const error_1 = require("../error");
const dbos_executor_1 = require("../dbos-executor");
const dbos_1 = require("../dbos");
const core_1 = require("@opentelemetry/core");
const api_1 = require("@opentelemetry/api");
const uuid_1 = require("uuid");
class MiddlewareClassRegistration extends decorators_1.ClassRegistration {
    authMiddleware;
    koaBodyParser;
    koaCors;
    koaMiddlewares;
    koaGlobalMiddlewares;
    constructor(ctor) {
        super(ctor);
    }
}
exports.MiddlewareClassRegistration = MiddlewareClassRegistration;
/////////////////////////////////
/* MIDDLEWARE CLASS DECORATORS */
/////////////////////////////////
/**
 * Define an authentication function for each endpoint in this class.
 */
function Authentication(authMiddleware) {
    if (authMiddleware === undefined) {
        throw new error_1.DBOSUndefinedDecoratorInputError("Authentication");
    }
    function clsdec(ctor) {
        const clsreg = (0, decorators_1.getOrCreateClassRegistration)(ctor);
        clsreg.authMiddleware = authMiddleware;
    }
    return clsdec;
}
exports.Authentication = Authentication;
/**
 * Define a Koa body parser applied before any middleware. If not set, the default @koa/bodyparser is used.
 */
function KoaBodyParser(koaBodyParser) {
    function clsdec(ctor) {
        const clsreg = (0, decorators_1.getOrCreateClassRegistration)(ctor);
        clsreg.koaBodyParser = koaBodyParser;
    }
    return clsdec;
}
exports.KoaBodyParser = KoaBodyParser;
/**
 * Define a Koa CORS policy applied before any middleware. If not set, the default @koa/cors (w/ .yaml config) is used.
 */
function KoaCors(koaCors) {
    function clsdec(ctor) {
        const clsreg = (0, decorators_1.getOrCreateClassRegistration)(ctor);
        clsreg.koaCors = koaCors;
    }
    return clsdec;
}
exports.KoaCors = KoaCors;
/**
 * Define Koa middleware that is applied in order to each endpoint in this class.
 */
function KoaMiddleware(...koaMiddleware) {
    koaMiddleware.forEach((i) => {
        if (i === undefined) {
            throw new error_1.DBOSUndefinedDecoratorInputError("KoaMiddleware");
        }
    });
    function clsdec(ctor) {
        const clsreg = (0, decorators_1.getOrCreateClassRegistration)(ctor);
        clsreg.koaMiddlewares = koaMiddleware;
    }
    return clsdec;
}
exports.KoaMiddleware = KoaMiddleware;
/**
 * Define Koa middleware that is applied to all requests, including this class, other classes,
 *   or requests that do not end up in DBOS handlers at all.
 */
function KoaGlobalMiddleware(...koaMiddleware) {
    koaMiddleware.forEach((i) => {
        if (i === undefined) {
            throw new error_1.DBOSUndefinedDecoratorInputError("KoaGlobalMiddleware");
        }
    });
    function clsdec(ctor) {
        const clsreg = (0, decorators_1.getOrCreateClassRegistration)(ctor);
        clsreg.koaGlobalMiddlewares = koaMiddleware;
    }
    return clsdec;
}
exports.KoaGlobalMiddleware = KoaGlobalMiddleware;
/**
 * Declare an OpenApi Security Scheme (https://spec.openapis.org/oas/v3.0.3#security-scheme-object
 * for the methods of a class. Note, this decorator is only used in OpenApi generation and does not
 * affect runtime behavior of the app.
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function OpenApiSecurityScheme(securityScheme) {
    return function (_ctor) { };
}
exports.OpenApiSecurityScheme = OpenApiSecurityScheme;
/////////////////////////////////
/* HTTP APP TRACING MIDDLEWARES */
/////////////////////////////////
exports.RequestIDHeader = "X-Request-ID";
function getOrGenerateRequestID(headers) {
    const reqID = headers[exports.RequestIDHeader.toLowerCase()]; // RequestIDHeader is expected to be a single value, so we dismiss the possible string[] returned type.
    if (reqID) {
        return reqID;
    }
    const newID = (0, uuid_1.v4)();
    headers[exports.RequestIDHeader.toLowerCase()] = newID; // This does not carry through the response
    return newID;
}
exports.getOrGenerateRequestID = getOrGenerateRequestID;
function createHTTPSpan(request, httpTracer) {
    // If present, retrieve the trace context from the request
    const extractedSpanContext = api_1.trace.getSpanContext(httpTracer.extract(api_1.ROOT_CONTEXT, request.headers, api_1.defaultTextMapGetter));
    let span;
    const spanAttributes = {
        operationType: dbos_executor_1.OperationType.HANDLER,
        requestID: request.requestID,
        requestIP: request.ip,
        requestURL: request.url,
        requestMethod: request.method,
    };
    if (extractedSpanContext === undefined) {
        // request.url should be defined by now. Let's cast it to string
        span = dbos_1.DBOS.executor.tracer.startSpan(request.url, spanAttributes);
    }
    else {
        extractedSpanContext.isRemote = true;
        span = dbos_1.DBOS.executor.tracer.startSpanWithContext(extractedSpanContext, request.url, spanAttributes);
    }
    return span;
}
exports.createHTTPSpan = createHTTPSpan;
async function koaTracingMiddleware(ctx, next) {
    // Retrieve or generate the request ID
    const requestID = getOrGenerateRequestID(ctx.request.headers);
    // Attach it to the response headers (here through Koa's context)
    ctx.set(exports.RequestIDHeader, requestID);
    const request = {
        headers: ctx.request.headers,
        rawHeaders: ctx.req.rawHeaders,
        params: ctx.params,
        body: ctx.request.body,
        rawBody: ctx.request.rawBody,
        query: ctx.request.query,
        querystring: ctx.request.querystring,
        url: ctx.request.url,
        ip: ctx.request.ip,
        method: ctx.request.method,
        requestID,
    };
    const httpTracer = new core_1.W3CTraceContextPropagator();
    const span = createHTTPSpan(request, httpTracer);
    await dbos_1.DBOS.withTracedContext(request.url, span, request, next);
    httpTracer.inject(api_1.trace.setSpanContext(api_1.ROOT_CONTEXT, span.spanContext()), {
        context: ctx,
    }, {
        set: (carrier, key, value) => {
            carrier.context.set(key, value);
        },
    });
    dbos_1.DBOS.executor.tracer.endSpan(span);
}
exports.koaTracingMiddleware = koaTracingMiddleware;
async function expressTracingMiddleware(req, res, next) {
    // Retrieve or generate the request ID
    const requestID = getOrGenerateRequestID(req.headers);
    // Attach it to the response headers (here through Express's response)
    res.setHeader(exports.RequestIDHeader, requestID);
    const request = {
        headers: req.headers,
        rawHeaders: req.rawHeaders,
        params: req.params,
        body: req.body,
        rawBody: req.rawBody,
        // query: req.query,
        querystring: req.url.split("?")[1],
        url: req.url,
        ip: req.ip,
        method: req.method,
        requestID,
    };
    const httpTracer = new core_1.W3CTraceContextPropagator();
    const span = createHTTPSpan(request, httpTracer);
    await dbos_1.DBOS.withTracedContext(request.url, span, request, next);
    // We could probably define a context type and type the parameters in the set closure (see Koa middleware above)
    httpTracer.inject(api_1.trace.setSpanContext(api_1.ROOT_CONTEXT, span.spanContext()), res, {
        set: (_, header, value) => res.setHeader(header, value),
    });
    dbos_1.DBOS.executor.tracer.endSpan(span);
}
exports.expressTracingMiddleware = expressTracingMiddleware;
//# sourceMappingURL=middleware.js.map