"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DrizzleUserDatabase = exports.KnexUserDatabase = exports.TypeORMDatabase = exports.PrismaUserDatabase = exports.PGNodeUserDatabase = exports.pgNodeIsKeyConflictError = exports.txnOutputIndexExistsQuery = exports.txnOutputTableExistsQuery = exports.schemaExistsQuery = exports.UserDatabaseName = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const pg_1 = require("pg");
const user_db_schema_1 = require("../schemas/user_db_schema");
const transaction_1 = require("./transaction");
exports.UserDatabaseName = {
    PGNODE: "pg-node",
    PRISMA: "prisma",
    TYPEORM: "typeorm",
    KNEX: "knex",
    DRIZZLE: "drizzle",
};
exports.schemaExistsQuery = `SELECT EXISTS (SELECT FROM information_schema.schemata WHERE schema_name = 'dbos')`;
exports.txnOutputTableExistsQuery = `SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_schema = 'dbos' AND table_name = 'transaction_outputs')`;
exports.txnOutputIndexExistsQuery = `SELECT EXISTS (SELECT FROM pg_indexes WHERE schemaname='dbos' AND tablename = 'transaction_outputs' AND indexname = 'transaction_outputs_created_at_index')`;
function pgNodeIsKeyConflictError(error) {
    if (!(error instanceof pg_1.DatabaseError)) {
        return false;
    }
    const pge = getPostgresErrorCode(error);
    return pge === "23505";
    function getPostgresErrorCode(error) {
        const dbErr = error;
        return dbErr.code ? dbErr.code : null;
    }
}
exports.pgNodeIsKeyConflictError = pgNodeIsKeyConflictError;
/**
 * node-postgres user data access interface
 */
class PGNodeUserDatabase {
    poolConfig;
    pool;
    constructor(poolConfig) {
        this.poolConfig = poolConfig;
        this.pool = new pg_1.Pool(poolConfig);
    }
    async init(debugMode = false) {
        if (!debugMode) {
            const schemaExists = await this.pool.query(exports.schemaExistsQuery);
            if (!schemaExists.rows[0].exists) {
                await this.pool.query(user_db_schema_1.createUserDBSchema);
            }
            const txnOutputTableExists = await this.pool.query(exports.txnOutputTableExistsQuery);
            if (!txnOutputTableExists.rows[0].exists) {
                await this.pool.query(user_db_schema_1.userDBSchema);
            }
            const txnIndexExists = await this.pool.query(exports.txnOutputIndexExistsQuery);
            if (!txnIndexExists.rows[0].exists) {
                await this.pool.query(user_db_schema_1.userDBIndex);
            }
        }
    }
    async destroy() {
        await this.pool.end();
    }
    getName() {
        return exports.UserDatabaseName.PGNODE;
    }
    async transaction(txn, config, ...args) {
        const client = await this.pool.connect();
        try {
            const readOnly = config.readOnly ?? false;
            const isolationLevel = config.isolationLevel ?? transaction_1.IsolationLevel.Serializable;
            await client.query(`BEGIN ISOLATION LEVEL ${isolationLevel}`);
            if (readOnly) {
                await client.query(`SET TRANSACTION READ ONLY`);
            }
            const result = await txn(client, ...args);
            await client.query(`COMMIT`);
            return result;
        }
        catch (err) {
            await client.query(`ROLLBACK`);
            throw err;
        }
        finally {
            client.release();
        }
    }
    async queryFunction(func, ...args) {
        const client = await this.pool.connect();
        try {
            return func(client, ...args);
        }
        finally {
            client.release();
        }
    }
    async query(sql, ...params) {
        return this.pool.query(sql, params).then((value) => {
            return value.rows;
        });
    }
    async queryWithClient(client, sql, ...params) {
        const pgClient = client;
        return pgClient.query(sql, params).then((value) => {
            return value.rows;
        });
    }
    getPostgresErrorCode(error) {
        const dbErr = error;
        return dbErr.code ? dbErr.code : null;
    }
    isRetriableTransactionError(error) {
        if (!(error instanceof pg_1.DatabaseError)) {
            return false;
        }
        return this.getPostgresErrorCode(error) === "40001";
    }
    isKeyConflictError(error) {
        if (!(error instanceof pg_1.DatabaseError)) {
            return false;
        }
        const pge = this.getPostgresErrorCode(error);
        return pge === "23505";
    }
    isFailedSqlTransactionError(error) {
        if (!(error instanceof pg_1.DatabaseError)) {
            return false;
        }
        return this.getPostgresErrorCode(error) === "25P02";
    }
    async createSchema() {
        return Promise.reject(new Error("createSchema() is not supported in PG user database."));
    }
    async dropSchema() {
        return Promise.reject(new Error("dropSchema() is not supported in PG user database."));
    }
}
exports.PGNodeUserDatabase = PGNodeUserDatabase;
const PrismaIsolationLevel = {
    ReadUncommitted: "ReadUncommitted",
    ReadCommitted: "ReadCommitted",
    RepeatableRead: "RepeatableRead",
    Serializable: "Serializable",
};
class PrismaUserDatabase {
    prisma;
    constructor(prisma) {
        this.prisma = prisma;
    }
    async init(debugMode = false) {
        if (!debugMode) {
            const schemaExists = await this.prisma.$queryRawUnsafe(exports.schemaExistsQuery);
            if (!schemaExists[0].exists) {
                await this.prisma.$queryRawUnsafe(user_db_schema_1.createUserDBSchema);
            }
            const txnOutputTableExists = await this.prisma.$queryRawUnsafe(exports.txnOutputTableExistsQuery);
            if (!txnOutputTableExists[0].exists) {
                await this.prisma.$queryRawUnsafe(user_db_schema_1.userDBSchema);
            }
            const txnIndexExists = await this.prisma.$queryRawUnsafe(exports.txnOutputIndexExistsQuery);
            if (!txnIndexExists[0].exists) {
                await this.prisma.$queryRawUnsafe(user_db_schema_1.userDBIndex);
            }
        }
    }
    async destroy() {
        await this.prisma.$disconnect();
    }
    getName() {
        return exports.UserDatabaseName.PRISMA;
    }
    async transaction(transaction, config, ...args) {
        let isolationLevel;
        if (config.isolationLevel === transaction_1.IsolationLevel.ReadUncommitted) {
            isolationLevel = PrismaIsolationLevel.ReadUncommitted;
        }
        else if (config.isolationLevel === transaction_1.IsolationLevel.ReadCommitted) {
            isolationLevel = PrismaIsolationLevel.ReadCommitted;
        }
        else if (config.isolationLevel === transaction_1.IsolationLevel.RepeatableRead) {
            isolationLevel = PrismaIsolationLevel.RepeatableRead;
        }
        else {
            isolationLevel = PrismaIsolationLevel.Serializable;
        }
        const result = await this.prisma.$transaction(async (tx) => {
            return await transaction(tx, ...args);
        }, { isolationLevel: isolationLevel });
        return result;
    }
    async queryFunction(func, ...args) {
        return func(this.prisma, ...args);
    }
    async query(sql, ...params) {
        return this.prisma.$queryRawUnsafe(sql, ...params);
    }
    async queryWithClient(client, sql, ...params) {
        const prismaClient = client;
        return prismaClient.$queryRawUnsafe(sql, ...params);
    }
    getPostgresErrorCode(error) {
        const dbErr = error;
        return dbErr.meta ? dbErr.meta.code : null;
    }
    isRetriableTransactionError(error) {
        return this.getPostgresErrorCode(error) === "40001";
    }
    isKeyConflictError(error) {
        return this.getPostgresErrorCode(error) === "23505";
    }
    isFailedSqlTransactionError(error) {
        return this.getPostgresErrorCode(error) === "25P02";
    }
    async createSchema() {
        return Promise.reject(new Error("createSchema() is not supported in Prisma user database."));
    }
    async dropSchema() {
        return Promise.reject(new Error("dropSchema() is not supported in Prisma user database."));
    }
}
exports.PrismaUserDatabase = PrismaUserDatabase;
/**
 * TypeORM user data access interface
 */
class TypeORMDatabase {
    ds;
    dataSource;
    constructor(ds) {
        this.ds = ds;
        this.dataSource = ds;
    }
    async init(debugMode = false) {
        if (!this.dataSource.isInitialized) {
            await this.dataSource.initialize(); // Need to initialize datasource even in debug mode.
        }
        if (!debugMode) {
            const schemaExists = await this.dataSource.query(exports.schemaExistsQuery);
            if (!schemaExists[0].exists) {
                await this.dataSource.query(user_db_schema_1.createUserDBSchema);
            }
            const txnOutputTableExists = await this.dataSource.query(exports.txnOutputTableExistsQuery);
            if (!txnOutputTableExists[0].exists) {
                await this.dataSource.query(user_db_schema_1.userDBSchema);
            }
            const txnIndexExists = await this.dataSource.query(exports.txnOutputIndexExistsQuery);
            if (!txnIndexExists[0].exists) {
                await this.dataSource.query(user_db_schema_1.userDBIndex);
            }
        }
    }
    async destroy() {
        if (this.dataSource.isInitialized) {
            await this.dataSource.destroy();
        }
    }
    getName() {
        return exports.UserDatabaseName.TYPEORM;
    }
    async transaction(txn, config, ...args) {
        const isolationLevel = config.isolationLevel ?? transaction_1.IsolationLevel.Serializable;
        return this.dataSource.manager.transaction(isolationLevel, async (transactionEntityManager) => {
            const result = await txn(transactionEntityManager, ...args);
            return result;
        });
    }
    async queryFunction(func, ...args) {
        return func(this.dataSource.manager, ...args);
    }
    async query(sql, ...params) {
        return this.dataSource.manager.query(sql, params).then((value) => {
            return value;
        });
    }
    async queryWithClient(client, sql, ...params) {
        const tClient = client;
        return tClient.query(sql, params).then((value) => {
            return value;
        });
    }
    getPostgresErrorCode(error) {
        const typeormErr = error;
        if (typeormErr.driverError) {
            const dbErr = typeormErr.driverError;
            return dbErr.code ? dbErr.code : null;
        }
        else {
            return null;
        }
    }
    isRetriableTransactionError(error) {
        return this.getPostgresErrorCode(error) === "40001";
    }
    isKeyConflictError(error) {
        return this.getPostgresErrorCode(error) === "23505";
    }
    isFailedSqlTransactionError(error) {
        return this.getPostgresErrorCode(error) === "25P02";
    }
    async createSchema() {
        return this.dataSource.synchronize();
    }
    async dropSchema() {
        return this.dataSource.dropDatabase();
    }
}
exports.TypeORMDatabase = TypeORMDatabase;
/**
 * Knex user data access interface
 */
class KnexUserDatabase {
    knex;
    constructor(knex) {
        this.knex = knex;
    }
    async init(debugMode = false) {
        if (!debugMode) {
            const schemaExists = await this.knex.raw(exports.schemaExistsQuery);
            if (!schemaExists.rows[0].exists) {
                await this.knex.raw(user_db_schema_1.createUserDBSchema);
            }
            const txnOutputTableExists = await this.knex.raw(exports.txnOutputTableExistsQuery);
            if (!txnOutputTableExists.rows[0].exists) {
                await this.knex.raw(user_db_schema_1.userDBSchema);
            }
            const txnIndexExists = await this.knex.raw(exports.txnOutputIndexExistsQuery);
            if (!txnIndexExists.rows[0].exists) {
                await this.knex.raw(user_db_schema_1.userDBIndex);
            }
        }
    }
    async destroy() {
        await this.knex.destroy();
    }
    getName() {
        return exports.UserDatabaseName.KNEX;
    }
    async transaction(transactionFunction, config, ...args) {
        let isolationLevel;
        if (config.isolationLevel === transaction_1.IsolationLevel.ReadUncommitted) {
            isolationLevel = "read uncommitted";
        }
        else if (config.isolationLevel === transaction_1.IsolationLevel.ReadCommitted) {
            isolationLevel = "read committed";
        }
        else if (config.isolationLevel === transaction_1.IsolationLevel.RepeatableRead) {
            isolationLevel = "repeatable read";
        }
        else {
            isolationLevel = "serializable";
        }
        const result = await this.knex.transaction(async (transactionClient) => {
            return await transactionFunction(transactionClient, ...args);
        }, { isolationLevel: isolationLevel, readOnly: config.readOnly ?? false });
        return result;
    }
    async queryFunction(func, ...args) {
        const result = await this.knex.transaction(async (transactionClient) => {
            return await func(transactionClient, ...args);
        }, { isolationLevel: "read committed", readOnly: true });
        return result;
    }
    async query(sql, ...params) {
        return this.queryWithClient(this.knex, sql, ...params);
    }
    async queryWithClient(client, sql, ...uparams) {
        const knexSql = sql.replace(/\$\d+/g, '?'); // Replace $1, $2... with ?
        let params = uparams;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        params = params.map(i => i === undefined ? null : i); // Set undefined parameters to null.
        const rows = await client.raw(knexSql, params);
        return rows.rows;
    }
    getPostgresErrorCode(error) {
        const dbErr = error;
        return dbErr.code ? dbErr.code : null;
    }
    isRetriableTransactionError(error) {
        return this.getPostgresErrorCode(error) === "40001";
    }
    isKeyConflictError(error) {
        return this.getPostgresErrorCode(error) === "23505";
    }
    isFailedSqlTransactionError(error) {
        return this.getPostgresErrorCode(error) === "25P02";
    }
    async createSchema() {
        return Promise.reject(new Error("createSchema() is not supported in Knex user database."));
    }
    async dropSchema() {
        return Promise.reject(new Error("dropSchema() is not supported in Knex user database."));
    }
}
exports.KnexUserDatabase = KnexUserDatabase;
/**
 * Drizzle user data access interface
 */
class DrizzleUserDatabase {
    pool;
    db;
    constructor(pool, db) {
        this.pool = pool;
        this.db = db;
    }
    async init(debugMode = false) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        const poolClient = this.db._.session.client;
        if (!debugMode) {
            const schemaExists = await poolClient.query(exports.schemaExistsQuery);
            if (!schemaExists.rows[0].exists) {
                await poolClient.query(user_db_schema_1.createUserDBSchema);
            }
            const txnOutputTableExists = await poolClient.query(exports.txnOutputTableExistsQuery);
            if (!txnOutputTableExists.rows[0].exists) {
                await poolClient.query(user_db_schema_1.userDBSchema);
            }
            const txnIndexExists = await poolClient.query(exports.txnOutputIndexExistsQuery);
            if (!txnIndexExists.rows[0].exists) {
                await poolClient.query(user_db_schema_1.userDBIndex);
            }
        }
    }
    async destroy() {
        await this.pool.end();
    }
    getName() {
        return exports.UserDatabaseName.DRIZZLE;
    }
    async transaction(transactionFunction, config, ...args) {
        let isolationLevel;
        if (config.isolationLevel === transaction_1.IsolationLevel.ReadUncommitted) {
            isolationLevel = "read uncommitted";
        }
        else if (config.isolationLevel === transaction_1.IsolationLevel.ReadCommitted) {
            isolationLevel = "read committed";
        }
        else if (config.isolationLevel === transaction_1.IsolationLevel.RepeatableRead) {
            isolationLevel = "repeatable read";
        }
        else {
            isolationLevel = "serializable";
        }
        const accessMode = config.readOnly ? 'read only' : 'read write';
        const result = await this.db.transaction(async (tx) => {
            return await transactionFunction(tx, ...args);
        }, { isolationLevel, accessMode });
        return result;
    }
    async queryFunction(func, ...args) {
        return func(this.db, ...args);
    }
    async query(sql, ...params) {
        return this.queryWithClient(this.db, sql, ...params);
    }
    async queryWithClient(client, sqlString, ...params) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        const sessionClient = client._.session.client;
        return sessionClient.query(sqlString, params).then((value) => {
            return value.rows;
        });
    }
    getPostgresErrorCode(error) {
        const dbErr = error;
        return dbErr.code ? dbErr.code : null;
    }
    isRetriableTransactionError(error) {
        return this.getPostgresErrorCode(error) === "40001";
    }
    isKeyConflictError(error) {
        return this.getPostgresErrorCode(error) === "23505";
    }
    isFailedSqlTransactionError(error) {
        return this.getPostgresErrorCode(error) === "25P02";
    }
    async createSchema() {
        return Promise.reject(new Error("createSchema() is not supported in Drizzle user database."));
    }
    async dropSchema() {
        return Promise.reject(new Error("dropSchema() is not supported in Drizzle user database."));
    }
}
exports.DrizzleUserDatabase = DrizzleUserDatabase;
//# sourceMappingURL=user_database.js.map