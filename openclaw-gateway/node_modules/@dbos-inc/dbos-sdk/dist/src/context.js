"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InitContext = exports.DBOSContextImpl = exports.runWithWorkflowContext = exports.runWithStepContext = exports.runWithTransactionContext = exports.runWithTopContext = exports.runWithHandlerContext = exports.runWithDBOSContext = exports.getNextWFID = exports.assertCurrentWorkflowContext = exports.assertCurrentDBOSContext = exports.getCurrentDBOSContext = exports.getCurrentContextStore = exports.asyncLocalCtx = void 0;
const logs_1 = require("./telemetry/logs");
const lodash_1 = require("lodash");
const error_1 = require("./error");
const async_hooks_1 = require("async_hooks");
const error_2 = require("./error");
function isWithinWorkflowCtx(ctx) {
    if (ctx.workflowId === undefined)
        return false;
    return true;
}
function isInStepCtx(ctx) {
    if (ctx.workflowId === undefined)
        return false;
    if (ctx.curStepFunctionId)
        return true;
    return false;
}
function isInTxnCtx(ctx) {
    if (ctx.workflowId === undefined)
        return false;
    if (ctx.curTxFunctionId)
        return true;
    return false;
}
function isInWorkflowCtx(ctx) {
    if (!isWithinWorkflowCtx(ctx))
        return false;
    if (isInStepCtx(ctx))
        return false;
    if (isInTxnCtx(ctx))
        return false;
    return true;
}
exports.asyncLocalCtx = new async_hooks_1.AsyncLocalStorage();
function getCurrentContextStore() {
    return exports.asyncLocalCtx.getStore();
}
exports.getCurrentContextStore = getCurrentContextStore;
function getCurrentDBOSContext() {
    return exports.asyncLocalCtx.getStore()?.ctx;
}
exports.getCurrentDBOSContext = getCurrentDBOSContext;
function assertCurrentDBOSContext() {
    const ctx = exports.asyncLocalCtx.getStore()?.ctx;
    if (!ctx)
        throw new error_1.DBOSNotRegisteredError("No current DBOS Context");
    return ctx;
}
exports.assertCurrentDBOSContext = assertCurrentDBOSContext;
function assertCurrentWorkflowContext() {
    const ctxs = getCurrentContextStore();
    if (!ctxs || !isInWorkflowCtx(ctxs)) {
        throw new error_2.DBOSInvalidWorkflowTransitionError();
    }
    const ctx = assertCurrentDBOSContext();
    return ctx;
}
exports.assertCurrentWorkflowContext = assertCurrentWorkflowContext;
function getNextWFID(assignedID) {
    let wfId = assignedID;
    if (!wfId) {
        const pctx = getCurrentContextStore();
        const nextID = pctx?.idAssignedForNextWorkflow;
        if (nextID) {
            wfId = nextID;
            pctx.idAssignedForNextWorkflow = undefined;
        }
    }
    return wfId;
}
exports.getNextWFID = getNextWFID;
async function runWithDBOSContext(ctx, callback) {
    return await exports.asyncLocalCtx.run({
        ctx,
        idAssignedForNextWorkflow: ctx.workflowUUID,
        request: ctx.request,
        authenticatedRoles: ctx.authenticatedRoles,
        authenticatedUser: ctx.authenticatedUser,
        span: ctx.span,
    }, callback);
}
exports.runWithDBOSContext = runWithDBOSContext;
async function runWithHandlerContext(ctx, callback) {
    return await exports.asyncLocalCtx.run({
        ctx,
        idAssignedForNextWorkflow: ctx.workflowUUID,
        request: ctx.request,
        authenticatedRoles: ctx.authenticatedRoles,
        authenticatedUser: ctx.authenticatedUser,
        span: ctx.span,
    }, callback);
}
exports.runWithHandlerContext = runWithHandlerContext;
async function runWithTopContext(ctx, callback) {
    return await exports.asyncLocalCtx.run(ctx, callback);
}
exports.runWithTopContext = runWithTopContext;
async function runWithTransactionContext(ctx, callback) {
    // Check we are in a workflow context and not in a step / transaction already
    const pctx = getCurrentContextStore();
    if (!pctx)
        throw new error_2.DBOSInvalidWorkflowTransitionError();
    if (!isInWorkflowCtx(pctx))
        throw new error_2.DBOSInvalidWorkflowTransitionError();
    return await exports.asyncLocalCtx.run({
        ctx,
        workflowId: ctx.workflowUUID,
        curTxFunctionId: ctx.functionID,
        parentCtx: pctx,
    }, callback);
}
exports.runWithTransactionContext = runWithTransactionContext;
async function runWithStepContext(ctx, callback) {
    // Check we are in a workflow context and not in a step / transaction already
    const pctx = getCurrentContextStore();
    if (!pctx)
        throw new error_2.DBOSInvalidWorkflowTransitionError();
    if (!isInWorkflowCtx(pctx))
        throw new error_2.DBOSInvalidWorkflowTransitionError();
    return await exports.asyncLocalCtx.run({
        ctx,
        workflowId: ctx.workflowUUID,
        curStepFunctionId: ctx.functionID,
        parentCtx: pctx,
    }, callback);
}
exports.runWithStepContext = runWithStepContext;
async function runWithWorkflowContext(ctx, callback) {
    // TODO: Check context, this could be a child workflow?
    return await exports.asyncLocalCtx.run({
        ctx,
        workflowId: ctx.workflowUUID,
    }, callback);
}
exports.runWithWorkflowContext = runWithWorkflowContext;
class DBOSContextImpl {
    operationName;
    span;
    request = {}; // Raw incoming HTTP request.
    authenticatedUser = ""; // The user that has been authenticated
    authenticatedRoles = []; // All roles the user has according to authentication
    assumedRole = ""; // Role in use - that user has and provided authorization to current function
    workflowUUID = ""; // Workflow UUID. Empty for HandlerContexts.
    executorID = process.env.DBOS__VMID || "local"; // Executor ID. Gathered from the environment and "local" otherwise
    applicationVersion = process.env.DBOS__APPVERSION || ""; // Application version. Gathered from the environment and empty otherwise
    applicationID = process.env.DBOS__APPID || ""; // Application ID. Gathered from the environment and empty otherwise
    logger; // Wrapper around the global logger for this context.
    constructor(operationName, span, logger, parentCtx) {
        this.operationName = operationName;
        this.span = span;
        if (parentCtx) {
            this.request = parentCtx.request;
            this.authenticatedUser = parentCtx.authenticatedUser;
            this.authenticatedRoles = parentCtx.authenticatedRoles;
            this.assumedRole = parentCtx.assumedRole;
            this.workflowUUID = parentCtx.workflowUUID;
        }
        this.logger = new logs_1.Logger(logger, this);
    }
    /*** Application configuration ***/
    applicationConfig;
    getConfig(key, defaultValue) {
        const value = (0, lodash_1.get)(this.applicationConfig, key, defaultValue);
        // If the key is found and the default value is provided, check whether the value is of the same type.
        if (value && defaultValue && typeof value !== typeof defaultValue) {
            throw new error_1.DBOSConfigKeyTypeError(key, typeof defaultValue, typeof value);
        }
        return value;
    }
}
exports.DBOSContextImpl = DBOSContextImpl;
/**
 * TODO : move logger and application, getConfig to a BaseContext which is at the root of all contexts
 */
class InitContext {
    dbosExec;
    logger;
    // All private Not exposed
    userDatabase;
    application;
    constructor(dbosExec) {
        this.dbosExec = dbosExec;
        this.logger = dbosExec.logger;
        this.userDatabase = dbosExec.userDatabase;
        this.application = dbosExec.config.application;
    }
    createUserSchema() {
        this.logger.warn("Schema synchronization is deprecated and unsafe for production use. Please use migrations instead: https://typeorm.io/migrations");
        return this.userDatabase.createSchema();
    }
    dropUserSchema() {
        this.logger.warn("Schema synchronization is deprecated and unsafe for production use. Please use migrations instead: https://typeorm.io/migrations");
        return this.userDatabase.dropSchema();
    }
    queryUserDB(sql, ...params) {
        return this.userDatabase.query(sql, ...params);
    }
    getConfig(key, defaultValue) {
        const value = (0, lodash_1.get)(this.application, key, defaultValue);
        // If the key is found and the default value is provided, check whether the value is of the same type.
        if (value && defaultValue && typeof value !== typeof defaultValue) {
            throw new error_1.DBOSConfigKeyTypeError(key, typeof defaultValue, typeof value);
        }
        return value;
    }
}
exports.InitContext = InitContext;
//# sourceMappingURL=context.js.map