"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RetrievedHandle = exports.InvokedHandle = exports.WorkflowContextImpl = exports.StatusString = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const dbos_executor_1 = require("./dbos-executor");
const transaction_1 = require("./transaction");
const error_1 = require("./error");
const serialize_error_1 = require("serialize-error");
const utils_1 = require("./utils");
const user_database_1 = require("./user_database");
const api_1 = require("@opentelemetry/api");
const context_1 = require("./context");
const decorators_1 = require("./decorators");
const procedure_1 = require("./procedure");
exports.StatusString = {
    PENDING: "PENDING",
    SUCCESS: "SUCCESS",
    ERROR: "ERROR",
    RETRIES_EXCEEDED: "RETRIES_EXCEEDED",
    CANCELLED: "CANCELLED",
    ENQUEUED: "ENQUEUED",
};
class WorkflowContextImpl extends context_1.DBOSContextImpl {
    workflowConfig;
    presetUUID;
    tempWfOperationType;
    tempWfOperationName;
    functionID = 0;
    #dbosExec;
    resultBuffer = new Map();
    isTempWorkflow;
    maxRecoveryAttempts;
    constructor(dbosExec, parentCtx, workflowUUID, workflowConfig, workflowName, presetUUID, tempWfOperationType = "", // "transaction", "procedure", "external", or "send"
    tempWfOperationName = "" // Name for the temporary workflow operation
    ) {
        const span = dbosExec.tracer.startSpan(workflowName, {
            status: exports.StatusString.PENDING,
            operationUUID: workflowUUID,
            operationType: dbos_executor_1.OperationType.WORKFLOW,
            authenticatedUser: parentCtx?.authenticatedUser ?? "",
            authenticatedRoles: parentCtx?.authenticatedRoles ?? [],
            assumedRole: parentCtx?.assumedRole ?? "",
        }, parentCtx?.span);
        super(workflowName, span, dbosExec.logger, parentCtx);
        this.workflowConfig = workflowConfig;
        this.presetUUID = presetUUID;
        this.tempWfOperationType = tempWfOperationType;
        this.tempWfOperationName = tempWfOperationName;
        this.workflowUUID = workflowUUID;
        this.#dbosExec = dbosExec;
        this.isTempWorkflow = dbos_executor_1.DBOSExecutor.tempWorkflowName === workflowName;
        this.applicationConfig = dbosExec.config.application;
        this.maxRecoveryAttempts = workflowConfig.maxRecoveryAttempts ? workflowConfig.maxRecoveryAttempts : 50;
    }
    functionIDGetIncrement() {
        return this.functionID++;
    }
    /**
     * Retrieve the transaction snapshot information of the current transaction
     */
    async #retrieveSnapshot(query) {
        const rows = await query("SELECT pg_current_snapshot()::text as txn_snapshot;", []);
        return rows[0].txn_snapshot;
    }
    retrieveTxSnapshot(client) {
        const func = (sql, args) => this.#dbosExec.userDatabase.queryWithClient(client, sql, ...args);
        return this.#retrieveSnapshot(func);
    }
    retrieveProcSnapshot(client) {
        const func = (sql, args) => client.query(sql, args).then(v => v.rows);
        return this.#retrieveSnapshot(func);
    }
    /**
     * Check if an operation has already executed in a workflow.
     * If it previously executed successfully, return its output.
     * If it previously executed and threw an error, throw that error.
     * Otherwise, return DBOSNull.
     * Also return the transaction snapshot information of this current transaction.
     */
    async #checkExecution(query, funcID) {
        // Note: we read the current snapshot, not the recorded one!
        const rows = await query("(SELECT output, error, txn_snapshot, true as recorded FROM dbos.transaction_outputs WHERE workflow_uuid=$1 AND function_id=$2 UNION ALL SELECT null as output, null as error, pg_current_snapshot()::text as txn_snapshot, false as recorded) ORDER BY recorded", [this.workflowUUID, funcID]);
        if (rows.length === 0 || rows.length > 2) {
            this.logger.error("Unexpected! This should never happen. Returned rows: " + rows.toString());
            throw new error_1.DBOSError("This should never happen. Returned rows: " + rows.toString());
        }
        const res = {
            output: dbos_executor_1.dbosNull,
            txn_snapshot: ""
        };
        // recorded=false row will be first because we used ORDER BY.
        res.txn_snapshot = rows[0].txn_snapshot;
        if (rows.length === 2) {
            if (utils_1.DBOSJSON.parse(rows[1].error) !== null) {
                throw (0, serialize_error_1.deserializeError)(utils_1.DBOSJSON.parse(rows[1].error));
            }
            else {
                res.output = utils_1.DBOSJSON.parse(rows[1].output);
            }
        }
        return res;
    }
    checkTxExecution(client, funcID) {
        const func = (sql, args) => this.#dbosExec.userDatabase.queryWithClient(client, sql, ...args);
        return this.#checkExecution(func, funcID);
    }
    checkProcExecution(client, funcID) {
        const func = (sql, args) => client.query(sql, args).then(v => v.rows);
        return this.#checkExecution(func, funcID);
    }
    /**
     * Write all entries in the workflow result buffer to the database.
     * If it encounters a primary key error, this indicates a concurrent execution with the same UUID, so throw an DBOSError.
     */
    async #flushResultBuffer(query, isKeyConflict) {
        const funcIDs = Array.from(this.resultBuffer.keys());
        if (funcIDs.length === 0) {
            return;
        }
        funcIDs.sort();
        try {
            let sqlStmt = "INSERT INTO dbos.transaction_outputs (workflow_uuid, function_id, output, error, txn_id, txn_snapshot, created_at) VALUES ";
            let paramCnt = 1;
            const values = [];
            for (const funcID of funcIDs) {
                // Capture output and also transaction snapshot information.
                // Initially, no txn_id because no queries executed.
                const recorded = this.resultBuffer.get(funcID);
                const output = recorded.output;
                const txnSnapshot = recorded.txn_snapshot;
                const createdAt = recorded.created_at;
                if (paramCnt > 1) {
                    sqlStmt += ", ";
                }
                sqlStmt += `($${paramCnt++}, $${paramCnt++}, $${paramCnt++}, $${paramCnt++}, null, $${paramCnt++}, $${paramCnt++})`;
                values.push(this.workflowUUID, funcID, utils_1.DBOSJSON.stringify(output), utils_1.DBOSJSON.stringify(null), txnSnapshot, createdAt);
            }
            this.logger.debug(sqlStmt);
            await query(sqlStmt, values);
        }
        catch (error) {
            if (isKeyConflict(error)) {
                // Serialization and primary key conflict (Postgres).
                throw new error_1.DBOSWorkflowConflictUUIDError(this.workflowUUID);
            }
            else {
                throw error;
            }
        }
    }
    flushResultBuffer(client) {
        const func = (sql, args) => this.#dbosExec.userDatabase.queryWithClient(client, sql, ...args);
        return this.#flushResultBuffer(func, (error) => this.#dbosExec.userDatabase.isKeyConflictError(error));
    }
    flushResultBufferProc(client) {
        const func = (sql, args) => client.query(sql, args).then(v => v.rows);
        return this.#flushResultBuffer(func, user_database_1.pgNodeIsKeyConflictError);
    }
    /**
     * Write a operation's output to the database.
     */
    async #recordOutput(query, funcID, txnSnapshot, output, isKeyConflict) {
        try {
            const serialOutput = utils_1.DBOSJSON.stringify(output);
            const rows = await query("INSERT INTO dbos.transaction_outputs (workflow_uuid, function_id, output, txn_id, txn_snapshot, created_at) VALUES ($1, $2, $3, (select pg_current_xact_id_if_assigned()::text), $4, $5) RETURNING txn_id;", [this.workflowUUID, funcID, serialOutput, txnSnapshot, Date.now()]);
            return rows[0].txn_id;
        }
        catch (error) {
            if (isKeyConflict(error)) {
                // Serialization and primary key conflict (Postgres).
                throw new error_1.DBOSWorkflowConflictUUIDError(this.workflowUUID);
            }
            else {
                throw error;
            }
        }
    }
    recordOutputTx(client, funcID, txnSnapshot, output) {
        const func = (sql, args) => this.#dbosExec.userDatabase.queryWithClient(client, sql, ...args);
        return this.#recordOutput(func, funcID, txnSnapshot, output, (error) => this.#dbosExec.userDatabase.isKeyConflictError(error));
    }
    recordOutputProc(client, funcID, txnSnapshot, output) {
        const func = (sql, args) => client.query(sql, args).then(v => v.rows);
        return this.#recordOutput(func, funcID, txnSnapshot, output, user_database_1.pgNodeIsKeyConflictError);
    }
    /**
     * Record an error in an operation to the database.
     */
    async #recordError(query, funcID, txnSnapshot, err, isKeyConflict) {
        try {
            const serialErr = utils_1.DBOSJSON.stringify((0, serialize_error_1.serializeError)(err));
            await query("INSERT INTO dbos.transaction_outputs (workflow_uuid, function_id, error, txn_id, txn_snapshot, created_at) VALUES ($1, $2, $3, null, $4, $5) RETURNING txn_id;", [this.workflowUUID, funcID, serialErr, txnSnapshot, Date.now()]);
        }
        catch (error) {
            if (isKeyConflict(error)) {
                // Serialization and primary key conflict (Postgres).
                throw new error_1.DBOSWorkflowConflictUUIDError(this.workflowUUID);
            }
            else {
                throw error;
            }
        }
    }
    recordErrorTx(client, funcID, txnSnapshot, err) {
        const func = (sql, args) => this.#dbosExec.userDatabase.queryWithClient(client, sql, ...args);
        return this.#recordError(func, funcID, txnSnapshot, err, (error) => this.#dbosExec.userDatabase.isKeyConflictError(error));
    }
    recordErrorProc(client, funcID, txnSnapshot, err) {
        const func = (sql, args) => client.query(sql, args).then(v => v.rows);
        return this.#recordError(func, funcID, txnSnapshot, err, user_database_1.pgNodeIsKeyConflictError);
    }
    /**
     * Invoke another workflow as its child workflow and return a workflow handle.
     * The child workflow is guaranteed to be executed exactly once, even if the workflow is retried with the same UUID.
     * We pass in itself as a parent context and assign the child workflow with a deterministic UUID "this.workflowUUID-functionID".
     * We also pass in its own workflowUUID and function ID so the invoked handle is deterministic.
     */
    async startChildWorkflow(wf, ...args) {
        // Note: cannot use invoke for childWorkflow because of potential recursive types on the workflow itself.
        const funcId = this.functionIDGetIncrement();
        const childUUID = this.workflowUUID + "-" + funcId;
        return this.#dbosExec.internalWorkflow(wf, {
            parentCtx: this, workflowUUID: childUUID,
        }, this.workflowUUID, funcId, ...args);
    }
    async invokeChildWorkflow(wf, ...args) {
        return this.startChildWorkflow(wf, ...args).then((handle) => handle.getResult());
    }
    /**
     * Generate a proxy object for the provided class that wraps direct calls (i.e. OpClass.someMethod(param))
     * to use WorkflowContext.Transaction(OpClass.someMethod, param);
     */
    proxyInvokeWF(object, workflowUUID, asyncWf, configuredInstance, queue) {
        const ops = (0, decorators_1.getRegisteredOperations)(object);
        const proxy = {};
        const funcId = this.functionIDGetIncrement();
        const childUUID = workflowUUID || (this.workflowUUID + "-" + funcId);
        const params = { workflowUUID: childUUID, parentCtx: this, configuredInstance, queueName: queue?.name };
        for (const op of ops) {
            if (asyncWf) {
                proxy[op.name] = op.workflowConfig
                    ? (...args) => this.#dbosExec.internalWorkflow(op.registeredFunction, params, this.workflowUUID, funcId, ...args)
                    : undefined;
            }
            else {
                proxy[op.name] = op.workflowConfig
                    ? (...args) => this.#dbosExec.internalWorkflow(op.registeredFunction, params, this.workflowUUID, funcId, ...args)
                        .then((handle) => handle.getResult())
                    : undefined;
            }
        }
        return proxy;
    }
    startWorkflow(target, workflowUUID, queue) {
        if (typeof target === 'function') {
            return this.proxyInvokeWF(target, workflowUUID, true, null, queue);
        }
        else {
            return this.proxyInvokeWF(target, workflowUUID, true, target, queue);
        }
    }
    invokeWorkflow(target, workflowUUID) {
        if (typeof target === 'function') {
            return this.proxyInvokeWF(target, workflowUUID, false, null);
        }
        else {
            return this.proxyInvokeWF(target, workflowUUID, false, target);
        }
    }
    async childWorkflow(wf, ...args) {
        return this.startChildWorkflow(wf, ...args);
    }
    async #invokeProcLocal(proc, args, span, config, funcId) {
        let retryWaitMillis = 1;
        const backoffFactor = 1.5;
        const maxRetryWaitMs = 2000; // Maximum wait 2 seconds.
        const readOnly = config.readOnly ?? false;
        while (true) {
            let txn_snapshot = "invalid";
            const wrappedProcedure = async (client) => {
                const ctxt = new procedure_1.StoredProcedureContextImpl(client, this, span, this.#dbosExec.logger, proc.name);
                if (this.presetUUID) {
                    const check = await this.checkProcExecution(client, this.functionID);
                    txn_snapshot = check.txn_snapshot;
                    if (check.output !== dbos_executor_1.dbosNull) {
                        ctxt.span.setAttribute("cached", true);
                        ctxt.span.setStatus({ code: api_1.SpanStatusCode.OK });
                        this.#dbosExec.tracer.endSpan(ctxt.span);
                        return check.output;
                    }
                }
                else {
                    // Collect snapshot information for read-only transactions and non-preset UUID transactions, if not already collected above
                    txn_snapshot = await this.retrieveProcSnapshot(client);
                }
                // For non-read-only transactions, flush the result buffer.
                if (!readOnly) {
                    await this.flushResultBufferProc(client);
                }
                let cresult;
                await (0, context_1.runWithDBOSContext)(ctxt, async () => {
                    cresult = await proc(ctxt, ...args);
                });
                const result = cresult;
                if (readOnly) {
                    // Buffer the output of read-only transactions instead of synchronously writing it.
                    const readOutput = {
                        output: result,
                        txn_snapshot: txn_snapshot,
                        created_at: Date.now(),
                    };
                    this.resultBuffer.set(funcId, readOutput);
                }
                else {
                    // Synchronously record the output of write transactions and obtain the transaction ID.
                    const pg_txn_id = await this.recordOutputProc(client, funcId, txn_snapshot, result);
                    ctxt.span.setAttribute("pg_txn_id", pg_txn_id);
                    this.resultBuffer.clear();
                }
                return result;
            };
            try {
                const result = await this.#dbosExec.executeProcedure(wrappedProcedure, { isolationLevel: config.isolationLevel });
                span.setStatus({ code: api_1.SpanStatusCode.OK });
                return result;
            }
            catch (err) {
                if (this.#dbosExec.userDatabase.isRetriableTransactionError(err)) {
                    // serialization_failure in PostgreSQL
                    span.addEvent("TXN SERIALIZATION FAILURE", { "retryWaitMillis": retryWaitMillis }, performance.now());
                    // Retry serialization failures.
                    await (0, utils_1.sleepms)(retryWaitMillis);
                    retryWaitMillis *= backoffFactor;
                    retryWaitMillis = retryWaitMillis < maxRetryWaitMs ? retryWaitMillis : maxRetryWaitMs;
                    continue;
                }
                // Record and throw other errors.
                const e = err;
                await this.#dbosExec.executeProcedure(async (client) => {
                    await this.flushResultBufferProc(client);
                    await this.recordErrorProc(client, funcId, txn_snapshot, e);
                }, { isolationLevel: transaction_1.IsolationLevel.ReadCommitted });
                await this.#dbosExec.userDatabase.transaction(async (client) => {
                    await this.flushResultBuffer(client);
                    await this.recordErrorTx(client, funcId, txn_snapshot, e);
                }, { isolationLevel: transaction_1.IsolationLevel.ReadCommitted });
                this.resultBuffer.clear();
                throw err;
            }
        }
    }
    async #invokeProcRemote(proc, args, span, config, funcId) {
        const readOnly = config.readOnly ?? false;
        const $jsonCtx = {
            request: this.request,
            authenticatedUser: this.authenticatedUser,
            authenticatedRoles: this.authenticatedRoles,
            assumedRole: this.assumedRole,
        };
        // Note, node-pg converts JS arrays to postgres array literals, so must call JSON.strigify on
        // args and bufferedResults before being passed to dbosExec.callProcedure
        const $args = [this.workflowUUID, funcId, this.presetUUID, $jsonCtx, null, JSON.stringify(args)];
        if (!readOnly) {
            // function_id, output, txn_snapshot, created_at
            const bufferedResults = new Array();
            for (const [functionID, { output, txn_snapshot, created_at }] of this.resultBuffer.entries()) {
                bufferedResults.push([functionID, output, txn_snapshot, created_at]);
            }
            // sort by function ID
            bufferedResults.sort((a, b) => a[0] - b[0]);
            $args.unshift(bufferedResults.length > 0 ? JSON.stringify(bufferedResults) : null);
        }
        const [{ return_value }] = await this.#dbosExec.callProcedure(proc, $args);
        const { error, output, txn_snapshot, txn_id, created_at } = return_value;
        // buffered results are persisted in r/w stored procs, even if it returns an error
        if (!readOnly) {
            this.resultBuffer.clear();
        }
        // if the stored proc returns an error, deserialize and throw it.
        // stored proc saves the error in tx_output before returning
        if (error) {
            throw (0, serialize_error_1.deserializeError)(error);
        }
        // if txn_snapshot is provided, the output needs to be buffered
        if (readOnly && txn_snapshot) {
            this.resultBuffer.set(funcId, {
                output,
                txn_snapshot,
                created_at: created_at ?? Date.now(),
            });
        }
        if (!readOnly) {
            this.resultBuffer.clear();
        }
        if (txn_id) {
            span.setAttribute("pg_txn_id", txn_id);
        }
        span.setStatus({ code: api_1.SpanStatusCode.OK });
        return output;
    }
    // TODO: ConfiguredInstance support
    async procedure(proc, ...args) {
        const procInfo = this.#dbosExec.getProcedureInfo(proc);
        if (procInfo === undefined) {
            throw new error_1.DBOSNotRegisteredError(proc.name);
        }
        const executeLocally = procInfo.config.executeLocally ?? false;
        const funcId = this.functionIDGetIncrement();
        const span = this.#dbosExec.tracer.startSpan(proc.name, {
            operationUUID: this.workflowUUID,
            operationType: dbos_executor_1.OperationType.PROCEDURE,
            authenticatedUser: this.authenticatedUser,
            assumedRole: this.assumedRole,
            authenticatedRoles: this.authenticatedRoles,
            readOnly: procInfo.config.readOnly ?? false,
            isolationLevel: procInfo.config.isolationLevel,
            executeLocally,
        }, this.span);
        try {
            const result = executeLocally
                ? await this.#invokeProcLocal(proc, args, span, procInfo.config, funcId)
                : await this.#invokeProcRemote(proc, args, span, procInfo.config, funcId);
            span.setStatus({ code: api_1.SpanStatusCode.OK });
            return result;
        }
        catch (e) {
            const { message } = e;
            span.setStatus({ code: api_1.SpanStatusCode.ERROR, message });
            throw e;
        }
        finally {
            this.#dbosExec.tracer.endSpan(span);
        }
    }
    /**
     * Execute a transactional function.
     * The transaction is guaranteed to execute exactly once, even if the workflow is retried with the same UUID.
     * If the transaction encounters a Postgres serialization error, retry it.
     * If it encounters any other error, throw it.
     */
    async transaction(txn, clsinst, ...args) {
        return this.#dbosExec.callTransactionFunction(txn, clsinst, this, ...args);
    }
    /**
     * Execute a step function.
     * If it encounters any error, retry according to its configured retry policy until the maximum number of attempts is reached, then throw an DBOSError.
     * The step may execute many times, but once it is complete, it will not re-execute.
     */
    async external(stepFn, clsInst, ...args) {
        return this.#dbosExec.callStepFunction(stepFn, clsInst, this, ...args);
    }
    /**
     * Send a message to a workflow identified by a UUID.
     * The message can optionally be tagged with a topic.
     */
    async send(destinationUUID, message, topic) {
        const functionID = this.functionIDGetIncrement();
        await this.#dbosExec.userDatabase.transaction(async (client) => {
            await this.flushResultBuffer(client);
        }, { isolationLevel: transaction_1.IsolationLevel.ReadCommitted });
        this.resultBuffer.clear();
        await this.#dbosExec.systemDatabase.send(this.workflowUUID, functionID, destinationUUID, message, topic);
    }
    /**
     * Consume and return the oldest unconsumed message sent to your UUID.
     * If a topic is specified, retrieve the oldest message tagged with that topic.
     * Otherwise, retrieve the oldest message with no topic.
     */
    async recv(topic, timeoutSeconds = dbos_executor_1.DBOSExecutor.defaultNotificationTimeoutSec) {
        const functionID = this.functionIDGetIncrement();
        const timeoutFunctionID = this.functionIDGetIncrement();
        await this.#dbosExec.userDatabase.transaction(async (client) => {
            await this.flushResultBuffer(client);
        }, { isolationLevel: transaction_1.IsolationLevel.ReadCommitted });
        this.resultBuffer.clear();
        return this.#dbosExec.systemDatabase.recv(this.workflowUUID, functionID, timeoutFunctionID, topic, timeoutSeconds);
    }
    /**
     * Emit a workflow event, represented as a key-value pair.
     * Events are immutable once set.
     */
    async setEvent(key, value) {
        const functionID = this.functionIDGetIncrement();
        await this.#dbosExec.userDatabase.transaction(async (client) => {
            await this.flushResultBuffer(client);
        }, { isolationLevel: transaction_1.IsolationLevel.ReadCommitted });
        this.resultBuffer.clear();
        await this.#dbosExec.systemDatabase.setEvent(this.workflowUUID, functionID, key, value);
    }
    /**
     * Generate a proxy object for the provided class that wraps direct calls (i.e. OpClass.someMethod(param))
     * to use WorkflowContext.Transaction(OpClass.someMethod, param);
     */
    invoke(object) {
        if (typeof object === 'function') {
            const ops = (0, decorators_1.getRegisteredOperations)(object);
            const proxy = {};
            for (const op of ops) {
                proxy[op.name] = op.txnConfig
                    ? (...args) => this.transaction(op.registeredFunction, null, ...args)
                    : op.commConfig
                        ? (...args) => this.external(op.registeredFunction, null, ...args)
                        : op.procConfig
                            ? (...args) => this.procedure(op.registeredFunction, ...args)
                            : undefined;
            }
            return proxy;
        }
        else {
            const targetInst = object;
            const ops = (0, decorators_1.getRegisteredOperations)(targetInst);
            const proxy = {};
            for (const op of ops) {
                proxy[op.name] = op.txnConfig
                    ? (...args) => this.transaction(op.registeredFunction, targetInst, ...args)
                    : op.commConfig
                        ? (...args) => this.external(op.registeredFunction, targetInst, ...args)
                        : undefined;
            }
            return proxy;
        }
    }
    /**
     * Wait for a workflow to emit an event, then return its value.
     */
    getEvent(targetUUID, key, timeoutSeconds = dbos_executor_1.DBOSExecutor.defaultNotificationTimeoutSec) {
        const functionID = this.functionIDGetIncrement();
        const timeoutFunctionID = this.functionIDGetIncrement();
        const params = {
            workflowUUID: this.workflowUUID,
            functionID,
            timeoutFunctionID
        };
        return this.#dbosExec.systemDatabase.getEvent(targetUUID, key, timeoutSeconds, params);
    }
    /**
     * Retrieve a handle for a workflow UUID.
     */
    retrieveWorkflow(targetUUID) {
        const functionID = this.functionIDGetIncrement();
        return new RetrievedHandle(this.#dbosExec.systemDatabase, targetUUID, this.workflowUUID, functionID);
    }
    /**
     * Sleep for the duration.
     */
    async sleepms(durationMS) {
        if (durationMS <= 0) {
            return;
        }
        const functionID = this.functionIDGetIncrement();
        return await this.#dbosExec.systemDatabase.sleepms(this.workflowUUID, functionID, durationMS);
    }
    async sleep(durationSec) {
        return this.sleepms(durationSec * 1000);
    }
}
exports.WorkflowContextImpl = WorkflowContextImpl;
/**
 * The handle returned when invoking a workflow with DBOSExecutor.workflow
 */
class InvokedHandle {
    systemDatabase;
    workflowPromise;
    workflowUUID;
    workflowName;
    callerUUID;
    callerFunctionID;
    constructor(systemDatabase, workflowPromise, workflowUUID, workflowName, callerUUID, callerFunctionID) {
        this.systemDatabase = systemDatabase;
        this.workflowPromise = workflowPromise;
        this.workflowUUID = workflowUUID;
        this.workflowName = workflowName;
        this.callerUUID = callerUUID;
        this.callerFunctionID = callerFunctionID;
    }
    getWorkflowUUID() {
        return this.workflowUUID;
    }
    async getStatus() {
        return this.systemDatabase.getWorkflowStatus(this.workflowUUID, this.callerUUID, this.callerFunctionID);
    }
    async getResult() {
        return this.workflowPromise;
    }
    async getWorkflowInputs() {
        return await this.systemDatabase.getWorkflowInputs(this.workflowUUID);
    }
}
exports.InvokedHandle = InvokedHandle;
/**
 * The handle returned when retrieving a workflow with DBOSExecutor.retrieve
 */
class RetrievedHandle {
    systemDatabase;
    workflowUUID;
    callerUUID;
    callerFunctionID;
    constructor(systemDatabase, workflowUUID, callerUUID, callerFunctionID) {
        this.systemDatabase = systemDatabase;
        this.workflowUUID = workflowUUID;
        this.callerUUID = callerUUID;
        this.callerFunctionID = callerFunctionID;
    }
    getWorkflowUUID() {
        return this.workflowUUID;
    }
    async getStatus() {
        return await this.systemDatabase.getWorkflowStatus(this.workflowUUID, this.callerUUID, this.callerFunctionID);
    }
    async getResult() {
        return await this.systemDatabase.getWorkflowResult(this.workflowUUID);
    }
    async getWorkflowInputs() {
        return await this.systemDatabase.getWorkflowInputs(this.workflowUUID);
    }
}
exports.RetrievedHandle = RetrievedHandle;
//# sourceMappingURL=workflow.js.map