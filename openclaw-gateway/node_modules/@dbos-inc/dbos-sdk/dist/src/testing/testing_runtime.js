"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestingRuntimeImpl = exports.createInternalTestRuntime = exports.createTestingRuntime = void 0;
const context_1 = require("../context");
const decorators_1 = require("../decorators");
const error_1 = require("../error");
const server_1 = require("../httpServer/server");
const dbos_executor_1 = require("../dbos-executor");
const config_1 = require("../dbos-runtime/config");
const lodash_1 = require("lodash");
const pg_1 = require("pg");
const scheduler_1 = require("../scheduler/scheduler");
const wfqueue_1 = require("../wfqueue");
const dbos_1 = require("../dbos");
/**
 * Create a testing runtime. Warn: this function will drop the existing system DB and create a clean new one. Don't run tests against your production database!
 */
async function createTestingRuntime(userClasses = undefined, configFilePath = config_1.dbosConfigFilePath, dropSysDB = true) {
    const [dbosConfig] = (0, config_1.parseConfigFile)({ configfile: configFilePath });
    if (dropSysDB) {
        // Drop system database. Testing runtime always uses Postgres for local testing.
        const pgSystemClient = new pg_1.Client({
            user: dbosConfig.poolConfig.user,
            port: dbosConfig.poolConfig.port,
            host: dbosConfig.poolConfig.host,
            password: dbosConfig.poolConfig.password,
            database: dbosConfig.poolConfig.database,
        });
        await pgSystemClient.connect();
        await pgSystemClient.query(`DROP DATABASE IF EXISTS ${dbosConfig.system_database};`);
        await pgSystemClient.end();
    }
    const otr = createInternalTestRuntime(userClasses, dbosConfig, undefined);
    return otr;
}
exports.createTestingRuntime = createTestingRuntime;
/**
 * For internal unit tests which allows us to provide different system DB and control its behavior.
 */
async function createInternalTestRuntime(userClasses, testConfig, systemDB) {
    const otr = new TestingRuntimeImpl();
    await otr.init(userClasses, testConfig, systemDB);
    return otr;
}
exports.createInternalTestRuntime = createInternalTestRuntime;
/**
 * This class provides a runtime to test DBOS functions in unit tests.
 */
class TestingRuntimeImpl {
    #server = null;
    #scheduler = null;
    #wfQueueRunner = null;
    #applicationConfig = {};
    #isInitialized = false;
    #dbosExec = null;
    /**
     * Initialize the testing runtime by loading user functions specified in classes and using the specified config.
     * This should be the first function call before any subsequent calls.
     */
    async init(userClasses, testConfig, systemDB) {
        const dbosConfig = testConfig ? [testConfig] : (0, config_1.parseConfigFile)();
        dbos_1.DBOS.dbosConfig = dbosConfig[0];
        this.#dbosExec = new dbos_executor_1.DBOSExecutor(dbosConfig[0], systemDB);
        this.#applicationConfig = this.#dbosExec.config.application ?? {};
        dbos_1.DBOS.globalLogger = this.#dbosExec.logger;
        await this.#dbosExec.init(userClasses);
        this.#server = new server_1.DBOSHttpServer(this.#dbosExec);
        await this.initEventReceivers();
        this.#applicationConfig = this.#dbosExec.config.application ?? {};
        this.#isInitialized = true;
    }
    async initEventReceivers() {
        for (const evtRcvr of this.#dbosExec.eventReceivers) {
            await evtRcvr.initialize(this.#dbosExec);
        }
        this.#scheduler = new scheduler_1.DBOSScheduler(this.#dbosExec);
        this.#scheduler.initScheduler();
        this.#wfQueueRunner = wfqueue_1.wfQueueRunner.dispatchLoop(this.#dbosExec);
    }
    /**
     * Release resources after tests.
     */
    async destroy() {
        // Only release once.
        if (this.#isInitialized) {
            await this.deactivateEventReceivers();
            await this.#server?.dbosExec.destroy();
            this.#isInitialized = false;
        }
    }
    async deactivateEventReceivers() {
        for (const evtRcvr of this.#server?.dbosExec?.eventReceivers || []) {
            try {
                await evtRcvr.destroy();
            }
            catch (err) {
                const e = err;
                this.#server?.dbosExec?.logger.warn(`Error destroying event receiver: ${e.message}`);
            }
        }
        await this.#scheduler?.destroyScheduler();
        try {
            wfqueue_1.wfQueueRunner.stop();
            await this.#wfQueueRunner;
        }
        catch (err) {
            const e = err;
            this.#server?.dbosExec?.logger.warn(`Error destroying workflow queue runner: ${e.message}`);
        }
    }
    getConfig(key, defaultValue) {
        const value = (0, lodash_1.get)(this.#applicationConfig, key, defaultValue);
        if (value && defaultValue && typeof value !== typeof defaultValue) {
            throw new error_1.DBOSConfigKeyTypeError(key, typeof defaultValue, typeof value);
        }
        return value;
    }
    setConfig(key, newValue) {
        (0, lodash_1.set)(this.#applicationConfig, key, newValue);
    }
    /**
     * Generate a proxy object for the provided class that wraps direct calls (i.e. OpClass.someMethod(param))
     * to invoke workflows, transactions, and steps;
     */
    mainInvoke(object, workflowUUID, params, asyncWf, clsinst, queue) {
        const dbosExec = this.getDBOSExec();
        const ops = (0, decorators_1.getRegisteredOperations)(clsinst ? clsinst : object);
        const proxy = {};
        // Creates a context to pass in necessary info.
        const span = dbosExec.tracer.startSpan("test");
        const oc = new context_1.DBOSContextImpl("test", span, dbosExec.logger);
        oc.authenticatedUser = params?.authenticatedUser ?? "";
        oc.request = params?.request ?? {};
        oc.authenticatedRoles = params?.authenticatedRoles ?? [];
        const wfParams = { workflowUUID: workflowUUID, parentCtx: oc, configuredInstance: clsinst, queueName: queue?.name };
        for (const op of ops) {
            if (asyncWf) {
                proxy[op.name] = op.txnConfig
                    ? (...args) => dbosExec.transaction(op.registeredFunction, wfParams, ...args)
                    : op.workflowConfig
                        ? (...args) => dbosExec.workflow(op.registeredFunction, wfParams, ...args)
                        : op.commConfig
                            ? (...args) => dbosExec.external(op.registeredFunction, wfParams, ...args)
                            : op.procConfig
                                ? (...args) => dbosExec.procedure(op.registeredFunction, wfParams, ...args)
                                : undefined;
            }
            else {
                proxy[op.name] = op.workflowConfig
                    ? (...args) => dbosExec.workflow(op.registeredFunction, wfParams, ...args).then((handle) => handle.getResult())
                    : undefined;
            }
        }
        return proxy;
    }
    invoke(object, workflowUUID, params) {
        if (typeof object === 'function') {
            return this.mainInvoke(object, workflowUUID, params, true, null);
        }
        else {
            const targetInst = object;
            return this.mainInvoke(targetInst.constructor, workflowUUID, params, true, targetInst);
        }
    }
    startWorkflow(object, workflowUUID, params, queue) {
        if (typeof object === 'function') {
            return this.mainInvoke(object, workflowUUID, params, true, null, queue);
        }
        else {
            const targetInst = object;
            return this.mainInvoke(targetInst.constructor, workflowUUID, params, true, targetInst, queue);
        }
    }
    invokeWorkflow(object, workflowUUID, params) {
        if (typeof object === 'function') {
            return this.mainInvoke(object, workflowUUID, params, false, null);
        }
        else {
            const targetInst = object;
            return this.mainInvoke(targetInst.constructor, workflowUUID, params, false, targetInst);
        }
    }
    /**
     * Return a request handler callback for node's native http/http2 server, which includes all registered HTTP endpoints.
     */
    getHandlersCallback() {
        if (!this.#server) {
            throw new error_1.DBOSError("Uninitialized testing runtime! Did you forget to call init() first?");
        }
        return this.#server.app.callback();
    }
    getAdminCallback() {
        if (!this.#server) {
            throw new error_1.DBOSError("Uninitialized testing runtime! Did you forget to call init() first?");
        }
        return this.#server.adminApp.callback();
    }
    async send(destinationUUID, message, topic, idempotencyKey) {
        return this.getDBOSExec().send(destinationUUID, message, topic, idempotencyKey);
    }
    async getEvent(workflowUUID, key, timeoutSeconds = dbos_executor_1.DBOSExecutor.defaultNotificationTimeoutSec) {
        return this.getDBOSExec().getEvent(workflowUUID, key, timeoutSeconds);
    }
    retrieveWorkflow(workflowUUID) {
        return this.getDBOSExec().retrieveWorkflow(workflowUUID);
    }
    async getWorkflows(input) {
        return await this.getDBOSExec().systemDatabase.getWorkflows(input);
    }
    async queryUserDB(sql, ...params) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        return this.getDBOSExec().userDatabase.query(sql, ...params);
    }
    async createUserSchema() {
        return this.getDBOSExec().userDatabase.createSchema();
    }
    dropUserSchema() {
        return this.getDBOSExec().userDatabase.dropSchema();
    }
    /**
     * For internal tests use only -- return the workflow executor object.
     */
    getDBOSExec() {
        if (!this.#server) {
            throw new error_1.DBOSError("Uninitialized testing runtime! Did you forget to call init() first?");
        }
        return this.#server.dbosExec;
    }
}
exports.TestingRuntimeImpl = TestingRuntimeImpl;
//# sourceMappingURL=testing_runtime.js.map