/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node/http" />
import { IncomingMessage } from "http";
import { HTTPRequest } from "../context";
import { ConfiguredInstance } from "../decorators";
import { AsyncHandlerWfFuncs, AsyncHandlerWfFuncInst, InvokeFuncs, InvokeFuncsInst, SyncHandlerWfFuncs, SyncHandlerWfFuncsInst } from "../httpServer/handler";
import { DBOSExecutor, DBOSConfig } from "../dbos-executor";
import { GetWorkflowsInput, GetWorkflowsOutput, WorkflowHandle } from "../workflow";
import { Http2ServerRequest, Http2ServerResponse } from "http2";
import { ServerResponse } from "http";
import { SystemDatabase } from "../system_database";
import { WorkflowQueue } from "../wfqueue";
/**
 * Create a testing runtime. Warn: this function will drop the existing system DB and create a clean new one. Don't run tests against your production database!
 */
export declare function createTestingRuntime(userClasses?: object[] | undefined, configFilePath?: string, dropSysDB?: boolean): Promise<TestingRuntime>;
export interface WorkflowInvokeParams {
    readonly authenticatedUser?: string;
    readonly authenticatedRoles?: string[];
    readonly request?: HTTPRequest;
}
export interface TestingRuntime {
    invoke<T extends ConfiguredInstance>(targetInst: T, workflowUUID?: string, params?: WorkflowInvokeParams): InvokeFuncsInst<T>;
    invoke<T extends object>(targetClass: T, workflowUUID?: string, params?: WorkflowInvokeParams): InvokeFuncs<T>;
    invokeWorkflow<T extends ConfiguredInstance>(targetCfg: T, workflowUUID?: string, params?: WorkflowInvokeParams): SyncHandlerWfFuncsInst<T>;
    invokeWorkflow<T extends object>(targetClass: T, workflowUUID?: string, params?: WorkflowInvokeParams): SyncHandlerWfFuncs<T>;
    startWorkflow<T extends ConfiguredInstance>(targetCfg: T, workflowUUID?: string, params?: WorkflowInvokeParams, queue?: WorkflowQueue): AsyncHandlerWfFuncInst<T>;
    startWorkflow<T extends object>(targetClass: T, workflowUUID?: string, params?: WorkflowInvokeParams, queue?: WorkflowQueue): AsyncHandlerWfFuncs<T>;
    retrieveWorkflow<R>(workflowUUID: string): WorkflowHandle<R>;
    getWorkflows(input: GetWorkflowsInput): Promise<GetWorkflowsOutput>;
    send<T>(destinationUUID: string, message: T, topic?: string, idempotencyKey?: string): Promise<void>;
    getEvent<T>(workflowUUID: string, key: string, timeoutSeconds?: number): Promise<T | null>;
    getHandlersCallback(): (req: IncomingMessage | Http2ServerRequest, res: ServerResponse | Http2ServerResponse) => Promise<void>;
    getAdminCallback(): (req: IncomingMessage | Http2ServerRequest, res: ServerResponse | Http2ServerResponse) => Promise<void>;
    getConfig<T>(key: string): T | undefined;
    getConfig<T>(key: string, defaultValue: T): T;
    setConfig<T>(key: string, newValue: T): void;
    queryUserDB<R>(sql: string, ...params: any[]): Promise<R[]>;
    createUserSchema(): Promise<void>;
    dropUserSchema(): Promise<void>;
    destroy(): Promise<void>;
    deactivateEventReceivers(): Promise<void>;
    initEventReceivers(): Promise<void>;
}
/**
 * For internal unit tests which allows us to provide different system DB and control its behavior.
 */
export declare function createInternalTestRuntime(userClasses: object[] | undefined, testConfig: DBOSConfig, systemDB?: SystemDatabase): Promise<TestingRuntime>;
/**
 * This class provides a runtime to test DBOS functions in unit tests.
 */
export declare class TestingRuntimeImpl implements TestingRuntime {
    #private;
    /**
     * Initialize the testing runtime by loading user functions specified in classes and using the specified config.
     * This should be the first function call before any subsequent calls.
     */
    init(userClasses?: object[], testConfig?: DBOSConfig, systemDB?: SystemDatabase): Promise<void>;
    initEventReceivers(): Promise<void>;
    /**
     * Release resources after tests.
     */
    destroy(): Promise<void>;
    deactivateEventReceivers(): Promise<void>;
    /**
     * Get Application Configuration.
    */
    getConfig<T>(key: string): T | undefined;
    getConfig<T>(key: string, defaultValue: T): T;
    setConfig<T>(key: string, newValue: T): void;
    /**
     * Generate a proxy object for the provided class that wraps direct calls (i.e. OpClass.someMethod(param))
     * to invoke workflows, transactions, and steps;
     */
    mainInvoke<T extends object>(object: T, workflowUUID: string | undefined, params: WorkflowInvokeParams | undefined, asyncWf: boolean, clsinst: ConfiguredInstance | null, queue?: WorkflowQueue): InvokeFuncs<T>;
    invoke<T extends object>(object: T | ConfiguredInstance, workflowUUID?: string, params?: WorkflowInvokeParams): InvokeFuncs<T> | InvokeFuncsInst<T>;
    startWorkflow<T extends object>(object: T, workflowUUID?: string, params?: WorkflowInvokeParams, queue?: WorkflowQueue): AsyncHandlerWfFuncs<T> | AsyncHandlerWfFuncInst<T>;
    invokeWorkflow<T extends object>(object: T | ConfiguredInstance, workflowUUID?: string, params?: WorkflowInvokeParams): SyncHandlerWfFuncs<T> | SyncHandlerWfFuncsInst<T>;
    /**
     * Return a request handler callback for node's native http/http2 server, which includes all registered HTTP endpoints.
     */
    getHandlersCallback(): (req: IncomingMessage | Http2ServerRequest, res: Http2ServerResponse | ServerResponse<IncomingMessage>) => Promise<void>;
    getAdminCallback(): (req: IncomingMessage | Http2ServerRequest, res: Http2ServerResponse | ServerResponse<IncomingMessage>) => Promise<void>;
    send<T>(destinationUUID: string, message: T, topic?: string, idempotencyKey?: string): Promise<void>;
    getEvent<T>(workflowUUID: string, key: string, timeoutSeconds?: number): Promise<T | null>;
    retrieveWorkflow<R>(workflowUUID: string): WorkflowHandle<R>;
    getWorkflows(input: GetWorkflowsInput): Promise<GetWorkflowsOutput>;
    queryUserDB<R>(sql: string, ...params: any[]): Promise<R[]>;
    createUserSchema(): Promise<void>;
    dropUserSchema(): Promise<void>;
    /**
     * For internal tests use only -- return the workflow executor object.
     */
    getDBOSExec(): DBOSExecutor;
}
//# sourceMappingURL=testing_runtime.d.ts.map