import { DBOSExecutor } from "./dbos-executor";
import { Transaction, TransactionContext } from "./transaction";
import { StepFunction, StepContext } from "./step";
import { SystemDatabase } from "./system_database";
import { UserDatabaseClient } from "./user_database";
import { HTTPRequest, DBOSContext, DBOSContextImpl } from './context';
import { ConfiguredInstance } from "./decorators";
import { StoredProcedure, StoredProcedureContext } from "./procedure";
import { InvokeFuncsInst } from "./httpServer/handler";
import { PoolClient } from "pg";
import { WorkflowQueue } from "./wfqueue";
export type Workflow<T extends unknown[], R> = (ctxt: WorkflowContext, ...args: T) => Promise<R>;
export type WorkflowFunction<T extends unknown[], R> = Workflow<T, R>;
export type ContextFreeFunction<T extends unknown[], R> = (...args: T) => Promise<R>;
export type TailParameters<T extends (arg: any, args: any[]) => any> = T extends (arg: any, ...args: infer P) => any ? P : never;
type TxFunc = (ctxt: TransactionContext<any>, ...args: any[]) => Promise<any>;
type StepFunc = (ctxt: StepContext, ...args: any[]) => Promise<any>;
type ProcFunc = (ctxt: StoredProcedureContext, ...args: any[]) => Promise<any>;
export type WFInvokeFuncs<T> = T extends ConfiguredInstance ? never : {
    [P in keyof T as T[P] extends TxFunc | StepFunc | ProcFunc ? P : never]: T[P] extends TxFunc | StepFunc | ProcFunc ? (...args: TailParameters<T[P]>) => ReturnType<T[P]> : never;
};
export type WFInvokeFuncsInst<T> = T extends ConfiguredInstance ? {
    [P in keyof T as T[P] extends TxFunc | StepFunc | ProcFunc ? P : never]: T[P] extends TxFunc | StepFunc | ProcFunc ? (...args: TailParameters<T[P]>) => ReturnType<T[P]> : never;
} : never;
export interface WorkflowParams {
    workflowUUID?: string;
    parentCtx?: DBOSContextImpl;
    configuredInstance?: ConfiguredInstance | null;
    recovery?: boolean;
    queueName?: string;
    executeWorkflow?: boolean;
}
export interface WorkflowConfig {
    maxRecoveryAttempts?: number;
}
export interface WorkflowStatus {
    readonly status: string;
    readonly workflowName: string;
    readonly workflowClassName: string;
    readonly workflowConfigName: string;
    readonly queueName?: string;
    readonly authenticatedUser: string;
    readonly assumedRole: string;
    readonly authenticatedRoles: string[];
    readonly request: HTTPRequest;
}
export interface GetWorkflowsInput {
    workflowName?: string;
    authenticatedUser?: string;
    startTime?: string;
    endTime?: string;
    status?: "PENDING" | "SUCCESS" | "ERROR" | "RETRIES_EXCEEDED" | "CANCELLED" | "ENQUEUED";
    applicationVersion?: string;
    limit?: number;
}
export interface GetWorkflowsOutput {
    workflowUUIDs: string[];
}
export interface GetWorkflowQueueInput {
    queueName?: string;
    startTime?: string;
    endTime?: string;
    limit?: number;
}
export interface GetWorkflowQueueOutput {
    workflows: {
        workflowID: string;
        queueName: string;
        createdAt: number;
        startedAt?: number;
        completedAt?: number;
    }[];
}
export interface PgTransactionId {
    txid: string;
}
export interface BufferedResult {
    output: unknown;
    txn_snapshot: string;
    created_at?: number;
}
export declare const StatusString: {
    readonly PENDING: "PENDING";
    readonly SUCCESS: "SUCCESS";
    readonly ERROR: "ERROR";
    readonly RETRIES_EXCEEDED: "RETRIES_EXCEEDED";
    readonly CANCELLED: "CANCELLED";
    readonly ENQUEUED: "ENQUEUED";
};
type WFFunc = (ctxt: WorkflowContext, ...args: any[]) => Promise<unknown>;
export type WfInvokeWfs<T> = {
    [P in keyof T]: T[P] extends WFFunc ? (...args: TailParameters<T[P]>) => ReturnType<T[P]> : never;
};
export type WfInvokeWfsAsync<T> = {
    [P in keyof T]: T[P] extends WFFunc ? (...args: TailParameters<T[P]>) => Promise<WorkflowHandle<Awaited<ReturnType<T[P]>>>> : never;
};
export type WfInvokeWfsInst<T> = T extends ConfiguredInstance ? {
    [P in keyof T]: T[P] extends WFFunc ? (...args: TailParameters<T[P]>) => ReturnType<T[P]> : never;
} : never;
export type WfInvokeWfsInstAsync<T> = T extends ConfiguredInstance ? {
    [P in keyof T]: T[P] extends WFFunc ? (...args: TailParameters<T[P]>) => Promise<WorkflowHandle<Awaited<ReturnType<T[P]>>>> : never;
} : never;
export interface WorkflowContext extends DBOSContext {
    invoke<T extends ConfiguredInstance>(targetCfg: T): InvokeFuncsInst<T>;
    invoke<T extends object>(targetClass: T): WFInvokeFuncs<T>;
    /** @deprecated See startWorkflow */
    startChildWorkflow<T extends any[], R>(wf: Workflow<T, R>, ...args: T): Promise<WorkflowHandle<R>>;
    /** @deprecated See invokeWorkflow */
    invokeChildWorkflow<T extends unknown[], R>(wf: Workflow<T, R>, ...args: T): Promise<R>;
    /** @deprecated calls startWorkflow */
    childWorkflow<T extends unknown[], R>(wf: Workflow<T, R>, ...args: T): Promise<WorkflowHandle<R>>;
    invokeWorkflow<T extends ConfiguredInstance>(targetClass: T, workflowUUID?: string): WfInvokeWfsInst<T>;
    invokeWorkflow<T extends object>(targetClass: T, workflowUUID?: string): WfInvokeWfs<T>;
    startWorkflow<T extends ConfiguredInstance>(targetClass: T, workflowUUID?: string, queue?: WorkflowQueue): WfInvokeWfsInstAsync<T>;
    startWorkflow<T extends object>(targetClass: T, workflowUUID?: string, queue?: WorkflowQueue): WfInvokeWfsAsync<T>;
    send<T>(destinationID: string, message: T, topic?: string): Promise<void>;
    recv<T>(topic?: string, timeoutSeconds?: number): Promise<T | null>;
    setEvent<T>(key: string, value: T): Promise<void>;
    getEvent<T>(workflowID: string, key: string, timeoutSeconds?: number): Promise<T | null>;
    retrieveWorkflow<R>(workflowID: string): WorkflowHandle<R>;
    sleepms(durationMS: number): Promise<void>;
    sleep(durationSec: number): Promise<void>;
}
export declare class WorkflowContextImpl extends DBOSContextImpl implements WorkflowContext {
    #private;
    readonly workflowConfig: WorkflowConfig;
    readonly presetUUID: boolean;
    readonly tempWfOperationType: string;
    readonly tempWfOperationName: string;
    functionID: number;
    readonly resultBuffer: Map<number, BufferedResult>;
    readonly isTempWorkflow: boolean;
    readonly maxRecoveryAttempts: number;
    constructor(dbosExec: DBOSExecutor, parentCtx: DBOSContextImpl | undefined, workflowUUID: string, workflowConfig: WorkflowConfig, workflowName: string, presetUUID: boolean, tempWfOperationType?: string, // "transaction", "procedure", "external", or "send"
    tempWfOperationName?: string);
    functionIDGetIncrement(): number;
    retrieveTxSnapshot(client: UserDatabaseClient): Promise<string>;
    retrieveProcSnapshot(client: PoolClient): Promise<string>;
    checkTxExecution<R>(client: UserDatabaseClient, funcID: number): Promise<BufferedResult>;
    checkProcExecution<R>(client: PoolClient, funcID: number): Promise<BufferedResult>;
    flushResultBuffer(client: UserDatabaseClient): Promise<void>;
    flushResultBufferProc(client: PoolClient): Promise<void>;
    recordOutputTx<R>(client: UserDatabaseClient, funcID: number, txnSnapshot: string, output: R): Promise<string>;
    recordOutputProc<R>(client: PoolClient, funcID: number, txnSnapshot: string, output: R): Promise<string>;
    recordErrorTx(client: UserDatabaseClient, funcID: number, txnSnapshot: string, err: Error): Promise<void>;
    recordErrorProc(client: PoolClient, funcID: number, txnSnapshot: string, err: Error): Promise<void>;
    /**
     * Invoke another workflow as its child workflow and return a workflow handle.
     * The child workflow is guaranteed to be executed exactly once, even if the workflow is retried with the same UUID.
     * We pass in itself as a parent context and assign the child workflow with a deterministic UUID "this.workflowUUID-functionID".
     * We also pass in its own workflowUUID and function ID so the invoked handle is deterministic.
     */
    startChildWorkflow<T extends unknown[], R>(wf: Workflow<T, R>, ...args: T): Promise<WorkflowHandle<R>>;
    invokeChildWorkflow<T extends unknown[], R>(wf: Workflow<T, R>, ...args: T): Promise<R>;
    /**
     * Generate a proxy object for the provided class that wraps direct calls (i.e. OpClass.someMethod(param))
     * to use WorkflowContext.Transaction(OpClass.someMethod, param);
     */
    proxyInvokeWF<T extends object>(object: T, workflowUUID: string | undefined, asyncWf: boolean, configuredInstance: ConfiguredInstance | null, queue?: WorkflowQueue): WfInvokeWfsAsync<T>;
    startWorkflow<T extends object>(target: T, workflowUUID?: string, queue?: WorkflowQueue): WfInvokeWfsAsync<T>;
    invokeWorkflow<T extends object>(target: T, workflowUUID?: string): WfInvokeWfs<T>;
    childWorkflow<T extends unknown[], R>(wf: Workflow<T, R>, ...args: T): Promise<WorkflowHandle<R>>;
    procedure<R>(proc: StoredProcedure<R>, ...args: unknown[]): Promise<R>;
    /**
     * Execute a transactional function.
     * The transaction is guaranteed to execute exactly once, even if the workflow is retried with the same UUID.
     * If the transaction encounters a Postgres serialization error, retry it.
     * If it encounters any other error, throw it.
     */
    transaction<T extends unknown[], R>(txn: Transaction<T, R>, clsinst: ConfiguredInstance | null, ...args: T): Promise<R>;
    /**
     * Execute a step function.
     * If it encounters any error, retry according to its configured retry policy until the maximum number of attempts is reached, then throw an DBOSError.
     * The step may execute many times, but once it is complete, it will not re-execute.
     */
    external<T extends unknown[], R>(stepFn: StepFunction<T, R>, clsInst: ConfiguredInstance | null, ...args: T): Promise<R>;
    /**
     * Send a message to a workflow identified by a UUID.
     * The message can optionally be tagged with a topic.
     */
    send<T>(destinationUUID: string, message: T, topic?: string): Promise<void>;
    /**
     * Consume and return the oldest unconsumed message sent to your UUID.
     * If a topic is specified, retrieve the oldest message tagged with that topic.
     * Otherwise, retrieve the oldest message with no topic.
     */
    recv<T>(topic?: string, timeoutSeconds?: number): Promise<T | null>;
    /**
     * Emit a workflow event, represented as a key-value pair.
     * Events are immutable once set.
     */
    setEvent<T>(key: string, value: T): Promise<void>;
    /**
     * Generate a proxy object for the provided class that wraps direct calls (i.e. OpClass.someMethod(param))
     * to use WorkflowContext.Transaction(OpClass.someMethod, param);
     */
    invoke<T extends object>(object: T | ConfiguredInstance): WFInvokeFuncs<T> | InvokeFuncsInst<T>;
    /**
     * Wait for a workflow to emit an event, then return its value.
     */
    getEvent<T>(targetUUID: string, key: string, timeoutSeconds?: number): Promise<T | null>;
    /**
     * Retrieve a handle for a workflow UUID.
     */
    retrieveWorkflow<R>(targetUUID: string): WorkflowHandle<R>;
    /**
     * Sleep for the duration.
     */
    sleepms(durationMS: number): Promise<void>;
    sleep(durationSec: number): Promise<void>;
}
/**
 * Object representing an active or completed workflow execution, identified by the workflow UUID.
 * Allows retrieval of information about the workflow.
 */
export interface WorkflowHandle<R> {
    /**
     * Retrieve the workflow's status.
     * Statuses are updated asynchronously.
     */
    getStatus(): Promise<WorkflowStatus | null>;
    /**
     * Await workflow completion and return its result.
     */
    getResult(): Promise<R>;
    /**
     * Return the workflow's UUID.
     */
    getWorkflowUUID(): string;
    /**
     * Return the workflow's inputs
     */
    getWorkflowInputs<T extends any[]>(): Promise<T>;
}
/**
 * The handle returned when invoking a workflow with DBOSExecutor.workflow
 */
export declare class InvokedHandle<R> implements WorkflowHandle<R> {
    readonly systemDatabase: SystemDatabase;
    readonly workflowPromise: Promise<R>;
    readonly workflowUUID: string;
    readonly workflowName: string;
    readonly callerUUID?: string | undefined;
    readonly callerFunctionID?: number | undefined;
    constructor(systemDatabase: SystemDatabase, workflowPromise: Promise<R>, workflowUUID: string, workflowName: string, callerUUID?: string | undefined, callerFunctionID?: number | undefined);
    getWorkflowUUID(): string;
    getStatus(): Promise<WorkflowStatus | null>;
    getResult(): Promise<R>;
    getWorkflowInputs<T extends any[]>(): Promise<T>;
}
/**
 * The handle returned when retrieving a workflow with DBOSExecutor.retrieve
 */
export declare class RetrievedHandle<R> implements WorkflowHandle<R> {
    readonly systemDatabase: SystemDatabase;
    readonly workflowUUID: string;
    readonly callerUUID?: string | undefined;
    readonly callerFunctionID?: number | undefined;
    constructor(systemDatabase: SystemDatabase, workflowUUID: string, callerUUID?: string | undefined, callerFunctionID?: number | undefined);
    getWorkflowUUID(): string;
    getStatus(): Promise<WorkflowStatus | null>;
    getResult(): Promise<R>;
    getWorkflowInputs<T extends any[]>(): Promise<T>;
}
export {};
//# sourceMappingURL=workflow.d.ts.map