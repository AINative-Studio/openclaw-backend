"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DBOS = void 0;
const context_1 = require("./context");
const dbos_executor_1 = require("./dbos-executor");
const logs_1 = require("./telemetry/logs");
const error_1 = require("./error");
const config_1 = require("./dbos-runtime/config");
const scheduler_1 = require("./scheduler/scheduler");
const decorators_1 = require("./decorators");
const utils_1 = require("./utils");
const server_1 = require("./httpServer/server");
const middleware_1 = require("./httpServer/middleware");
const wfqueue_1 = require("./wfqueue");
const handlerTypes_1 = require("./httpServer/handlerTypes");
const lodash_1 = require("lodash");
function httpApiDec(verb, url) {
    return function apidec(target, propertyKey, inDescriptor) {
        const { descriptor, registration } = (0, decorators_1.registerAndWrapContextFreeFunction)(target, propertyKey, inDescriptor);
        const handlerRegistration = registration;
        handlerRegistration.apiURL = url;
        handlerRegistration.apiType = verb;
        return descriptor;
    };
}
class DBOS {
    ///////
    // Lifecycle
    ///////
    static adminServer = undefined;
    static appServer = undefined;
    static setConfig(config, runtimeConfig) {
        DBOS.dbosConfig = config;
        DBOS.runtimeConfig = runtimeConfig;
    }
    // For unit testing purposes only
    static setAppConfig(key, newValue) {
        const conf = DBOS.dbosConfig?.application;
        if (!conf)
            throw new error_1.DBOSExecutorNotInitializedError();
        (0, lodash_1.set)(conf, key, newValue);
    }
    static async launch(httpApps) {
        // Do nothing is DBOS is already initialized
        if (dbos_executor_1.DBOSExecutor.globalInstance)
            return;
        // Initialize the DBOS executor
        if (!DBOS.dbosConfig) {
            const [dbosConfig, runtimeConfig] = (0, config_1.parseConfigFile)();
            DBOS.dbosConfig = dbosConfig;
            DBOS.runtimeConfig = runtimeConfig;
        }
        dbos_executor_1.DBOSExecutor.globalInstance = new dbos_executor_1.DBOSExecutor(DBOS.dbosConfig);
        const executor = dbos_executor_1.DBOSExecutor.globalInstance;
        await executor.init();
        dbos_executor_1.DBOSExecutor.globalInstance.scheduler = new scheduler_1.DBOSScheduler(dbos_executor_1.DBOSExecutor.globalInstance);
        dbos_executor_1.DBOSExecutor.globalInstance.scheduler.initScheduler();
        dbos_executor_1.DBOSExecutor.globalInstance.wfqEnded = wfqueue_1.wfQueueRunner.dispatchLoop(dbos_executor_1.DBOSExecutor.globalInstance);
        for (const evtRcvr of dbos_executor_1.DBOSExecutor.globalInstance.eventReceivers) {
            await evtRcvr.initialize(dbos_executor_1.DBOSExecutor.globalInstance);
        }
        // Start the DBOS admin server
        const logger = DBOS.logger;
        if (DBOS.runtimeConfig) {
            const adminApp = server_1.DBOSHttpServer.setupAdminApp(executor);
            await server_1.DBOSHttpServer.checkPortAvailabilityIPv4Ipv6(DBOS.runtimeConfig.admin_port, logger);
            DBOS.adminServer = adminApp.listen(DBOS.runtimeConfig.admin_port, () => {
                this.logger.info(`DBOS Admin Server is running at http://localhost:${DBOS.runtimeConfig?.admin_port}`);
            });
        }
        if (httpApps) {
            if (httpApps.koaApp) {
                DBOS.logger.info("Setting up Koa tracing middleware");
                httpApps.koaApp.use(middleware_1.koaTracingMiddleware);
            }
            if (httpApps.expressApp) {
                DBOS.logger.info("Setting up Express tracing middleware");
                httpApps.expressApp.use(middleware_1.expressTracingMiddleware);
            }
            if (httpApps.fastifyApp) {
                // Fastify can use express or middie under the hood, for middlewares.
                // Middie happens to have the same semantic than express.
                // See https://fastify.dev/docs/latest/Reference/Middleware/
                DBOS.logger.info("Setting up Fastify tracing middleware");
                httpApps.fastifyApp.use(middleware_1.expressTracingMiddleware);
            }
            if (httpApps.nestApp) {
                // Nest.kj can use express or fastify under the hood. With fastify, Nest.js uses middie.
                DBOS.logger.info("Setting up NestJS tracing middleware");
                httpApps.nestApp.use(middleware_1.expressTracingMiddleware);
            }
        }
    }
    static async shutdown() {
        // Stop the app server
        if (DBOS.appServer) {
            DBOS.appServer.close();
            DBOS.appServer = undefined;
        }
        // Stop the admin server
        if (DBOS.adminServer) {
            DBOS.adminServer.close();
            DBOS.adminServer = undefined;
        }
        // Stop the executor
        if (dbos_executor_1.DBOSExecutor.globalInstance) {
            await dbos_executor_1.DBOSExecutor.globalInstance.deactivateEventReceivers();
            await dbos_executor_1.DBOSExecutor.globalInstance.destroy();
            dbos_executor_1.DBOSExecutor.globalInstance = undefined;
        }
    }
    static get executor() {
        if (!dbos_executor_1.DBOSExecutor.globalInstance) {
            throw new error_1.DBOSExecutorNotInitializedError();
        }
        return dbos_executor_1.DBOSExecutor.globalInstance;
    }
    static async launchAppHTTPServer() {
        if (!dbos_executor_1.DBOSExecutor.globalInstance) {
            throw new error_1.DBOSExecutorNotInitializedError();
        }
        // Create the DBOS HTTP server
        //  This may be a no-op if there are no registered endpoints
        const server = new server_1.DBOSHttpServer(dbos_executor_1.DBOSExecutor.globalInstance);
        if (DBOS.runtimeConfig) {
            // This will not listen if there's no decorated endpoint
            DBOS.appServer = await server.appListen(DBOS.runtimeConfig.port);
        }
    }
    // This retrieves the HTTP handlers callback for DBOS HTTP.
    //  (This is the one that handles the @DBOS.getApi, etc., methods.)
    // Useful for testing purposes, or to combine the DBOS service with routes.
    // If you are using your own HTTP server, this won't return anything.
    static getHTTPHandlersCallback() {
        if (!server_1.DBOSHttpServer.instance) {
            return undefined;
        }
        return server_1.DBOSHttpServer.instance.app.callback();
    }
    //////
    // Globals
    //////
    static globalLogger;
    static dbosConfig;
    static runtimeConfig = undefined;
    static invokeWrappers = new Map();
    //////
    // Context
    //////
    static get logger() {
        const ctx = (0, context_1.getCurrentDBOSContext)();
        if (ctx)
            return ctx.logger;
        const executor = dbos_executor_1.DBOSExecutor.globalInstance;
        if (executor)
            return executor.logger;
        return new logs_1.GlobalLogger();
    }
    static get span() {
        const ctx = (0, context_1.getCurrentDBOSContext)();
        if (ctx)
            return ctx.span;
        return undefined;
    }
    static getRequest() {
        return (0, context_1.getCurrentDBOSContext)()?.request;
    }
    static get request() {
        const r = DBOS.getRequest();
        if (!r)
            throw new error_1.DBOSError("`DBOS.request` accessed from outside of HTTP requests");
        return r;
    }
    static getKoaContext() {
        return (0, context_1.getCurrentDBOSContext)()?.koaContext;
    }
    static get koaContext() {
        const r = DBOS.getKoaContext();
        if (!r)
            throw new error_1.DBOSError("`DBOS.koaContext` accessed from outside koa request");
        return r;
    }
    static get workflowID() {
        return (0, context_1.getCurrentDBOSContext)()?.workflowUUID;
    }
    static get authenticatedUser() {
        return (0, context_1.getCurrentDBOSContext)()?.authenticatedUser ?? "";
    }
    static get authenticatedRoles() {
        return (0, context_1.getCurrentDBOSContext)()?.authenticatedRoles ?? [];
    }
    static get assumedRole() {
        return (0, context_1.getCurrentDBOSContext)()?.assumedRole ?? "";
    }
    static isInTransaction() {
        return (0, context_1.getCurrentContextStore)()?.curTxFunctionId !== undefined;
    }
    static isInStep() {
        return (0, context_1.getCurrentContextStore)()?.curStepFunctionId !== undefined;
    }
    static isWithinWorkflow() {
        return (0, context_1.getCurrentContextStore)()?.workflowId !== undefined;
    }
    static isInWorkflow() {
        return DBOS.isWithinWorkflow() && !DBOS.isInTransaction() && !DBOS.isInStep();
    }
    // TODO CTX parent workflow ID
    // sql session (various forms)
    static get sqlClient() {
        if (!DBOS.isInTransaction())
            throw new error_1.DBOSInvalidWorkflowTransitionError();
        const ctx = (0, context_1.assertCurrentDBOSContext)();
        return ctx.client;
    }
    static get pgClient() {
        const client = DBOS.sqlClient;
        // TODO CTX check!
        return client;
    }
    static get knexClient() {
        const client = DBOS.sqlClient;
        // TODO CTX check!
        return client;
    }
    static get prismaClient() {
        const client = DBOS.sqlClient;
        // TODO CTX check!
        return client;
    }
    static get typeORMClient() {
        const client = DBOS.sqlClient;
        // TODO CTX check!
        return client;
    }
    static get drizzleClient() {
        const client = DBOS.sqlClient;
        // TODO CTX check!
        return client;
    }
    static getConfig(key, defaultValue) {
        const ctx = (0, context_1.getCurrentDBOSContext)();
        if (ctx && defaultValue)
            return ctx.getConfig(key, defaultValue);
        if (ctx)
            return ctx.getConfig(key);
        if (DBOS.executor)
            return DBOS.executor.getConfig(key, defaultValue);
        return defaultValue;
    }
    //////
    // Workflow and other operations
    //////
    static getWorkflowStatus(workflowID) {
        return DBOS.executor.getWorkflowStatus(workflowID);
    }
    static retrieveWorkflow(workflowID) {
        return DBOS.executor.retrieveWorkflow(workflowID);
    }
    static async getWorkflows(input) {
        return await DBOS.executor.getWorkflows(input);
    }
    static async getWorkflowQueue(input) {
        return await DBOS.executor.getWorkflowQueue(input);
    }
    static async sleepms(durationMS) {
        if (DBOS.isWithinWorkflow()) {
            if (DBOS.isInTransaction() || DBOS.isInStep()) {
                throw new error_1.DBOSInvalidWorkflowTransitionError();
            }
            return (0, context_1.getCurrentDBOSContext)().sleepms(durationMS);
        }
        await (0, utils_1.sleepms)(durationMS);
    }
    static async sleepSeconds(durationSec) {
        return this.sleepms(durationSec * 1000);
    }
    static async sleep(durationMS) {
        return this.sleepms(durationMS);
    }
    static async withNextWorkflowID(wfid, callback) {
        const pctx = (0, context_1.getCurrentContextStore)();
        if (pctx) {
            const pcwfid = pctx.idAssignedForNextWorkflow;
            try {
                pctx.idAssignedForNextWorkflow = wfid;
                return callback();
            }
            finally {
                pctx.idAssignedForNextWorkflow = pcwfid;
            }
        }
        else {
            return (0, context_1.runWithTopContext)({ idAssignedForNextWorkflow: wfid }, callback);
        }
    }
    static async withTracedContext(callerName, span, request, callback) {
        const pctx = (0, context_1.getCurrentContextStore)();
        if (pctx) {
            pctx.operationCaller = callerName;
            pctx.span = span;
            pctx.request = request;
            return callback();
        }
        else {
            return (0, context_1.runWithTopContext)({ span, request }, callback);
        }
    }
    static async withAuthedContext(authedUser, authedRoles, callback) {
        const pctx = (0, context_1.getCurrentContextStore)();
        if (pctx) {
            pctx.authenticatedUser = authedUser;
            pctx.authenticatedRoles = authedRoles;
            return callback();
        }
        else {
            return (0, context_1.runWithTopContext)({ authenticatedUser: authedUser, authenticatedRoles: authedRoles }, callback);
        }
    }
    // This generic setter helps users calling DBOS operation to pass a name, later used in seeding a parent OTel span for the operation.
    static async withNamedContext(callerName, callback) {
        const pctx = (0, context_1.getCurrentContextStore)();
        if (pctx) {
            pctx.operationCaller = callerName;
            return callback();
        }
        else {
            return (0, context_1.runWithTopContext)({ operationCaller: callerName }, callback);
        }
    }
    static async withWorkflowQueue(wfq, callback) {
        const pctx = (0, context_1.getCurrentContextStore)();
        if (pctx) {
            const pcwfq = pctx.queueAssignedForWorkflows;
            try {
                pctx.queueAssignedForWorkflows = wfq;
                return callback();
            }
            finally {
                pctx.queueAssignedForWorkflows = pcwfq;
            }
        }
        else {
            return (0, context_1.runWithTopContext)({ queueAssignedForWorkflows: wfq }, callback);
        }
    }
    static startWorkflow(target, params) {
        if (typeof target === 'function') {
            return DBOS.proxyInvokeWF(target, null, params);
        }
        else {
            return DBOS.proxyInvokeWF(target, target, params);
        }
    }
    static proxyInvokeWF(object, configuredInstance, inParams) {
        const ops = (0, decorators_1.getRegisteredOperations)(object);
        const proxy = {};
        let wfId = (0, context_1.getNextWFID)(inParams?.workflowID);
        const pctx = (0, context_1.getCurrentContextStore)();
        // If this is called from within a workflow, this is a child workflow,
        //  For OAOO, we will need a consistent ID formed from the parent WF and call number
        if (DBOS.isWithinWorkflow()) {
            const wfctx = (0, context_1.assertCurrentWorkflowContext)();
            const funcId = wfctx.functionIDGetIncrement();
            wfId = wfId || (wfctx.workflowUUID + "-" + funcId);
            const wfParams = {
                workflowUUID: wfId,
                parentCtx: wfctx,
                configuredInstance,
                queueName: inParams?.queueName ?? pctx?.queueAssignedForWorkflows
            };
            for (const op of ops) {
                proxy[op.name] = op.workflowConfig
                    ? (...args) => dbos_executor_1.DBOSExecutor.globalInstance.internalWorkflow(op.registeredFunction, wfParams, wfctx.workflowUUID, funcId, ...args)
                    : undefined;
            }
            return proxy;
        }
        // Else, we setup a parent context that includes all the potential metadata the application could have set in DBOSLocalCtx
        let parentCtx = undefined;
        if (pctx) {
            // If pctx has no span, e.g., has not been setup through `withTracedContext`, set up a parent span for the workflow here.
            let span = pctx.span;
            if (!span) {
                span = DBOS.executor.tracer.startSpan(pctx.operationCaller || "startWorkflow", {
                    operationUUID: wfId,
                    operationType: pctx.operationType,
                    authenticatedUser: pctx.authenticatedUser,
                    assumedRole: pctx.assumedRole,
                    authenticatedRoles: pctx.authenticatedRoles,
                });
            }
            parentCtx = new context_1.DBOSContextImpl(pctx.operationCaller || "startWorkflow", span, DBOS.logger);
            parentCtx.request = pctx.request || {};
            parentCtx.authenticatedUser = pctx.authenticatedUser || "";
            parentCtx.assumedRole = pctx.assumedRole || "";
            parentCtx.authenticatedRoles = pctx.authenticatedRoles || [];
            parentCtx.workflowUUID = wfId || "";
        }
        const wfParams = {
            workflowUUID: wfId,
            queueName: inParams?.queueName ?? pctx?.queueAssignedForWorkflows,
            configuredInstance,
            parentCtx,
        };
        for (const op of ops) {
            proxy[op.name] = op.workflowConfig
                ? (...args) => DBOS.executor.workflow(op.registeredFunction, wfParams, ...args)
                : undefined;
        }
        // TODO CTX - should we put helpful errors for any function that may have "compiled" but is not a workflow?
        return proxy;
    }
    static invoke(object) {
        if (!DBOS.isWithinWorkflow()) {
            // Run the temp workflow way...
            if (typeof object === 'function') {
                const ops = (0, decorators_1.getRegisteredOperations)(object);
                const proxy = {};
                for (const op of ops) {
                    proxy[op.name] = op.txnConfig
                        ? (...args) => dbos_executor_1.DBOSExecutor.globalInstance.transaction(op.registeredFunction, {}, ...args)
                        : op.commConfig
                            ? (...args) => dbos_executor_1.DBOSExecutor.globalInstance.external(op.registeredFunction, {}, ...args)
                            : op.procConfig
                                ? (...args) => dbos_executor_1.DBOSExecutor.globalInstance.procedure(op.registeredFunction, {}, ...args)
                                : undefined;
                }
                return proxy;
            }
            else {
                const targetInst = object;
                const ops = (0, decorators_1.getRegisteredOperations)(targetInst);
                const proxy = {};
                for (const op of ops) {
                    proxy[op.name] = op.txnConfig
                        ? (...args) => dbos_executor_1.DBOSExecutor.globalInstance.transaction(op.registeredFunction, { configuredInstance: targetInst }, ...args)
                        : op.commConfig
                            ? (...args) => dbos_executor_1.DBOSExecutor.globalInstance.external(op.registeredFunction, { configuredInstance: targetInst }, ...args)
                            : undefined;
                }
                return proxy;
            }
        }
        const wfctx = (0, context_1.assertCurrentWorkflowContext)();
        if (typeof object === 'function') {
            const ops = (0, decorators_1.getRegisteredOperations)(object);
            const proxy = {};
            for (const op of ops) {
                proxy[op.name] = op.txnConfig
                    ? (...args) => dbos_executor_1.DBOSExecutor.globalInstance.callTransactionFunction(op.registeredFunction, null, wfctx, ...args)
                    : op.commConfig
                        ? (...args) => dbos_executor_1.DBOSExecutor.globalInstance.callStepFunction(op.registeredFunction, null, wfctx, ...args)
                        : op.procConfig
                            ? (...args) => wfctx.procedure(op.registeredFunction, ...args)
                            : undefined;
            }
            return proxy;
        }
        else {
            const targetInst = object;
            const ops = (0, decorators_1.getRegisteredOperations)(targetInst);
            const proxy = {};
            for (const op of ops) {
                proxy[op.name] = op.txnConfig
                    ? (...args) => dbos_executor_1.DBOSExecutor.globalInstance.callTransactionFunction(op.registeredFunction, targetInst, wfctx, ...args)
                    : op.commConfig
                        ? (...args) => dbos_executor_1.DBOSExecutor.globalInstance.callStepFunction(op.registeredFunction, targetInst, wfctx, ...args)
                        : undefined;
            }
            return proxy;
        }
    }
    static async send(destinationID, message, topic) {
        if (DBOS.isWithinWorkflow()) {
            if (!DBOS.isInWorkflow()) {
                throw new error_1.DBOSInvalidWorkflowTransitionError();
            }
            return (0, context_1.getCurrentDBOSContext)().send(destinationID, message, topic);
        }
        return DBOS.executor.send(destinationID, message, topic);
    }
    static async recv(topic, timeoutSeconds) {
        if (DBOS.isWithinWorkflow()) {
            if (!DBOS.isInWorkflow()) {
                throw new error_1.DBOSInvalidWorkflowTransitionError();
            }
            return (0, context_1.getCurrentDBOSContext)().recv(topic, timeoutSeconds);
        }
        throw new error_1.DBOSInvalidWorkflowTransitionError(); // Only workflows can recv
    }
    static async setEvent(key, value) {
        if (DBOS.isWithinWorkflow()) {
            if (!DBOS.isInWorkflow()) {
                throw new error_1.DBOSInvalidWorkflowTransitionError();
            }
            return (0, context_1.getCurrentDBOSContext)().setEvent(key, value);
        }
        throw new error_1.DBOSInvalidWorkflowTransitionError(); // Only workflows can set event
    }
    static async getEvent(workflowID, key, timeoutSeconds) {
        if (DBOS.isWithinWorkflow()) {
            if (!DBOS.isInWorkflow()) {
                throw new error_1.DBOSInvalidWorkflowTransitionError();
            }
            return (0, context_1.getCurrentDBOSContext)().getEvent(workflowID, key, timeoutSeconds);
        }
        return DBOS.executor.getEvent(workflowID, key, timeoutSeconds);
    }
    //////
    // Decorators
    //////
    static scheduled(schedulerConfig) {
        function scheddec(target, propertyKey, inDescriptor) {
            const { descriptor, registration } = (0, decorators_1.registerAndWrapContextFreeFunction)(target, propertyKey, inDescriptor);
            const schedRegistration = registration;
            schedRegistration.schedulerConfig = schedulerConfig;
            return descriptor;
        }
        return scheddec;
    }
    static workflow(config = {}) {
        function decorator(target, propertyKey, inDescriptor) {
            const { descriptor, registration } = (0, decorators_1.registerAndWrapContextFreeFunction)(target, propertyKey, inDescriptor);
            registration.workflowConfig = config;
            const invokeWrapper = async function (...rawArgs) {
                const pctx = (0, context_1.getCurrentContextStore)();
                let inst = undefined;
                if (typeof this === 'function') {
                    // This is static
                }
                else {
                    inst = this;
                    if (!("name" in inst)) {
                        throw new error_1.DBOSInvalidWorkflowTransitionError();
                    }
                }
                let wfId = (0, context_1.getNextWFID)(undefined);
                // If this is called from within a workflow, this is a child workflow,
                //  For OAOO, we will need a consistent ID formed from the parent WF and call number
                if (DBOS.isWithinWorkflow()) {
                    const wfctx = (0, context_1.assertCurrentWorkflowContext)();
                    const funcId = wfctx.functionIDGetIncrement();
                    wfId = wfId || (wfctx.workflowUUID + "-" + funcId);
                    const params = {
                        workflowUUID: wfId,
                        parentCtx: wfctx,
                        configuredInstance: inst,
                        queueName: pctx?.queueAssignedForWorkflows
                    };
                    const cwfh = await dbos_executor_1.DBOSExecutor.globalInstance.internalWorkflow(registration.registeredFunction, params, wfctx.workflowUUID, funcId, ...rawArgs);
                    return await cwfh.getResult();
                }
                // Else, we setup a parent context that includes all the potential metadata the application could have set in DBOSLocalCtx
                let parentCtx = undefined;
                if (pctx) {
                    // If pctx has no span, e.g., has not been setup through `withTracedContext`, set up a parent span for the workflow here.
                    let span = pctx.span;
                    if (!span) {
                        span = DBOS.executor.tracer.startSpan(pctx.operationCaller || "workflowCaller", {
                            operationUUID: wfId,
                            operationType: pctx.operationType,
                            authenticatedUser: pctx.authenticatedUser,
                            assumedRole: pctx.assumedRole,
                            authenticatedRoles: pctx.authenticatedRoles,
                        });
                    }
                    parentCtx = new context_1.DBOSContextImpl(pctx.operationCaller || "workflowCaller", span, DBOS.logger);
                    parentCtx.request = pctx.request || {};
                    parentCtx.authenticatedUser = pctx.authenticatedUser || "";
                    parentCtx.assumedRole = pctx.assumedRole || "";
                    parentCtx.authenticatedRoles = pctx.authenticatedRoles || [];
                    parentCtx.workflowUUID = wfId || "";
                }
                const wfParams = {
                    workflowUUID: wfId,
                    queueName: pctx?.queueAssignedForWorkflows,
                    configuredInstance: inst,
                    parentCtx,
                };
                const handle = await DBOS.executor.workflow(registration.registeredFunction, wfParams, ...rawArgs);
                return await handle.getResult();
            };
            descriptor.value = invokeWrapper;
            registration.wrappedFunction = invokeWrapper;
            Object.defineProperty(invokeWrapper, "name", {
                value: registration.name,
            });
            (0, decorators_1.registerFunctionWrapper)(invokeWrapper, registration);
            // TODO CTX this should not be in here already, or if it is we need to do something different...
            DBOS.invokeWrappers.set(invokeWrapper, registration.registeredFunction);
            return descriptor;
        }
        return decorator;
    }
    static transaction(config = {}) {
        function decorator(target, propertyKey, inDescriptor) {
            const { descriptor, registration } = (0, decorators_1.registerAndWrapContextFreeFunction)(target, propertyKey, inDescriptor);
            registration.txnConfig = config;
            const invokeWrapper = async function (...rawArgs) {
                let inst = undefined;
                if (typeof this === 'function') {
                    // This is static
                }
                else {
                    inst = this;
                    if (!("name" in inst)) {
                        throw new error_1.DBOSInvalidWorkflowTransitionError();
                    }
                }
                if (DBOS.isWithinWorkflow()) {
                    const wfctx = (0, context_1.assertCurrentWorkflowContext)();
                    return await dbos_executor_1.DBOSExecutor.globalInstance.callTransactionFunction(registration.registeredFunction, inst ?? null, wfctx, ...rawArgs);
                }
                const wfParams = {
                    configuredInstance: inst
                };
                return await DBOS.executor.transaction(registration.registeredFunction, wfParams, ...rawArgs);
            };
            descriptor.value = invokeWrapper;
            registration.wrappedFunction = invokeWrapper;
            Object.defineProperty(invokeWrapper, "name", {
                value: registration.name,
            });
            return descriptor;
        }
        return decorator;
    }
    static step(config = {}) {
        function decorator(target, propertyKey, inDescriptor) {
            const { descriptor, registration } = (0, decorators_1.registerAndWrapContextFreeFunction)(target, propertyKey, inDescriptor);
            registration.commConfig = config;
            const invokeWrapper = async function (...rawArgs) {
                let inst = undefined;
                if (typeof this === 'function') {
                    // This is static
                }
                else {
                    inst = this;
                    if (!("name" in inst)) {
                        throw new error_1.DBOSInvalidWorkflowTransitionError();
                    }
                }
                if (DBOS.isWithinWorkflow()) {
                    const wfctx = (0, context_1.assertCurrentWorkflowContext)();
                    return await dbos_executor_1.DBOSExecutor.globalInstance.callStepFunction(registration.registeredFunction, inst ?? null, wfctx, ...rawArgs);
                }
                const wfParams = {
                    configuredInstance: inst
                };
                return await DBOS.executor.external(registration.registeredFunction, wfParams, ...rawArgs);
            };
            descriptor.value = invokeWrapper;
            registration.wrappedFunction = invokeWrapper;
            Object.defineProperty(invokeWrapper, "name", {
                value: registration.name,
            });
            return descriptor;
        }
        return decorator;
    }
    static getApi(url) {
        return httpApiDec(handlerTypes_1.APITypes.GET, url);
    }
    static postApi(url) {
        return httpApiDec(handlerTypes_1.APITypes.POST, url);
    }
    static putApi(url) {
        return httpApiDec(handlerTypes_1.APITypes.PUT, url);
    }
    static patchApi(url) {
        return httpApiDec(handlerTypes_1.APITypes.PATCH, url);
    }
    static deleteApi(url) {
        return httpApiDec(handlerTypes_1.APITypes.DELETE, url);
    }
    static defaultRequiredRole(anyOf) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        function clsdec(ctor) {
            const clsreg = (0, decorators_1.getOrCreateClassRegistration)(ctor);
            clsreg.requiredRole = anyOf;
        }
        return clsdec;
    }
    static requiredRole(anyOf) {
        function apidec(target, propertyKey, inDescriptor) {
            const { descriptor, registration } = (0, decorators_1.registerAndWrapContextFreeFunction)(target, propertyKey, inDescriptor);
            registration.requiredRole = anyOf;
            return descriptor;
        }
        return apidec;
    }
    /////
    // Registration, etc
    /////
    static configureInstance(cls, name, ...args) {
        return (0, decorators_1.configureInstance)(cls, name, ...args);
    }
    // Function registration
    static registerAndWrapContextFreeFunction(target, propertyKey, descriptor) {
        return (0, decorators_1.registerAndWrapContextFreeFunction)(target, propertyKey, descriptor);
    }
    static async executeWorkflowById(workflowId, startNewWorkflow = false) {
        if (!dbos_executor_1.DBOSExecutor.globalInstance) {
            throw new error_1.DBOSExecutorNotInitializedError();
        }
        return dbos_executor_1.DBOSExecutor.globalInstance.executeWorkflowUUID(workflowId, startNewWorkflow);
    }
    static async recoverPendingWorkflows(executorIDs = ["local"]) {
        if (!dbos_executor_1.DBOSExecutor.globalInstance) {
            throw new error_1.DBOSExecutorNotInitializedError();
        }
        return dbos_executor_1.DBOSExecutor.globalInstance.recoverPendingWorkflows(executorIDs);
    }
}
exports.DBOS = DBOS;
//# sourceMappingURL=dbos.js.map