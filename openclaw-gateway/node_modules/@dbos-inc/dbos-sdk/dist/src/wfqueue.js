"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wfQueueRunner = exports.WorkflowQueue = void 0;
const debugpoint_1 = require("./debugpoint");
const error_1 = require("./error");
class WorkflowQueue {
    name;
    concurrency;
    rateLimit;
    constructor(name, concurrency, rateLimit) {
        this.name = name;
        this.concurrency = concurrency;
        this.rateLimit = rateLimit;
        if (exports.wfQueueRunner.wfQueuesByName.has(name)) {
            throw new error_1.DBOSInitializationError(`Workflow Queue '${name}' defined multiple times`);
        }
        exports.wfQueueRunner.wfQueuesByName.set(name, this);
    }
}
exports.WorkflowQueue = WorkflowQueue;
class WFQueueRunner {
    wfQueuesByName = new Map();
    isRunning = false;
    interruptResolve;
    stop() {
        if (!this.isRunning)
            return;
        this.isRunning = false;
        if (this.interruptResolve) {
            this.interruptResolve();
        }
    }
    async dispatchLoop(exec) {
        this.isRunning = true;
        while (this.isRunning) {
            // Wait for either the timeout or an interruption
            let timer;
            const timeoutPromise = new Promise((resolve) => {
                timer = setTimeout(() => {
                    resolve();
                }, 1000);
            });
            await Promise.race([
                timeoutPromise,
                new Promise((_, reject) => this.interruptResolve = reject)
            ])
                .catch(() => { exec.logger.debug("Workflow queue loop interrupted!"); }); // Interrupt sleep throws
            clearTimeout(timer);
            if (!this.isRunning) {
                break;
            }
            // Check queues
            for (const [_qn, q] of this.wfQueuesByName) {
                let wfids;
                try {
                    wfids = await exec.systemDatabase.findAndMarkStartableWorkflows(q);
                }
                catch (e) {
                    const err = e;
                    exec.logger.warn(`Error getting startable workflows: ${err.message}`);
                    // On the premise that this was a transaction conflict error, just try again later.
                    wfids = [];
                }
                if (wfids.length > 0) {
                    await (0, debugpoint_1.debugTriggerPoint)(debugpoint_1.DEBUG_TRIGGER_WORKFLOW_QUEUE_START);
                }
                for (const wfid of wfids) {
                    try {
                        const _wfh = await exec.executeWorkflowUUID(wfid);
                    }
                    catch (e) {
                        exec.logger.warn(`Could not execute workflow with id ${wfid}`);
                        exec.logger.warn(e);
                    }
                }
            }
        }
    }
    logRegisteredEndpoints(exec) {
        const logger = exec.logger;
        logger.info("Workflow queues:");
        for (const [qn, q] of this.wfQueuesByName) {
            const conc = q.concurrency !== undefined ? `${q.concurrency}` : 'No concurrency limit set';
            logger.info(`    ${qn}: ${conc}`);
        }
    }
}
exports.wfQueueRunner = new WFQueueRunner();
//# sourceMappingURL=wfqueue.js.map